<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wan Zhiyan</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-11T17:04:34.580Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wantake</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Correlation function</title>
    <link href="http://example.com/2024/10/06/Spin-corr/"/>
    <id>http://example.com/2024/10/06/Spin-corr/</id>
    <published>2024-10-06T11:27:25.000Z</published>
    <updated>2024-10-11T17:04:34.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><p>Updating</p><h6 id="short-review-summary"><a href="#short-review-summary" class="headerlink" title="short review &amp; summary"></a>short review &amp; summary</h6><ol><li>In spin chain model the luttinger liquid theory shows spin correlation $C \sim 1&#x2F;r$ with odd-even oscillations.</li><li>In gapped excitations model shows exponentially decaying of correlation.</li><li>Critical scaling behavior of correlation $C \sim r^{-(d-2 + \eta)}$.</li><li>Several special transition( Neel order to VBS ) shows bahavior of power-law decaying $\to$ exponentially decaying.</li></ol><h2 id="Spin-correlation-function"><a href="#Spin-correlation-function" class="headerlink" title="Spin correlation function"></a>Spin correlation function</h2><h3 id="As-order-parameter"><a href="#As-order-parameter" class="headerlink" title="As order parameter."></a>As order parameter.</h3><p><strong>1D Heisenberg chain.</strong>  </p><p>The spin correlation function has <strong>power-law decay</strong>:</p><p>$$<br>C(r) &#x3D; \langle \vec{S}<em>i \cdot \vec{S}</em>{i+r} \rangle \sim (-1)^{r} \frac{1}{r}<br>$$</p><p>for large $r$ ,  where the sign means odd and even oscillations:  $r_{\text{even}} &#x3D; 2,4,6,…, r_{\text{odd}}&#x3D; 1,3,5,…$ .  And this oscillation should be symmetric about zero.</p><p>Since choose plot $(-1)^r \cdot r \cdot C(r)$, it should be converge to a constant $\to 0.25$ when $r \to \infty$.    （$0.25 &#x3D; 1&#x2F;4$ is contributed by spin $S &#x3D; 1&#x2F;2$）.  The graph<span style="color: blue;">[ See ref.2 absolute value of the spin correlation on Page 100 Fig 34 ]</span> shows the longest-distance correlation.  Odd-even grid points still oscillate.<span style="color: blue;">[ See ref.2 mentioned about <strong>this oscillations</strong> on Page 100, reference is also provided: J. Voit, Rep. Prog. Phys. 58 977 (1995) which is about Luttinger liquid ]</span>.</p><p>If the system has <strong>gapped excitations</strong>, its ground state correlation is <strong>exponentially decaying</strong>. <span style="color: blue;">[ See ref.2 mentioned: Haldane Chain on Page 14, even number coupled chains on Page 15 ]</span></p><p><strong>Néel(order) - VBS(order) transition</strong><span style="color: blue;">[ See ref.2: Neel-VBS transition of J-Q model on Page 22 ]</span></p><p>For the longest distance, while $r_{max} &#x3D; L&#x2F;2$ on the periodic $L\times L$ lattice, in the VBS phase($J&#x2F;Q \to 0$) it should be</p><p>$$<br>C(r&#x3D;L&#x2F;2) \to 0, L\to \infty<br>$$</p><p>In Neel phase correlation is finite(because of long-range order).  Another correlation is mentioned: dimer correlation which should vanish in Neel phase when $L \to \infty$. </p><p>This is similar to Dimerization transition.(But different model)</p><p><strong>Dimerization Transition.</strong> <span style="color: blue;">[ See ref.2: next-near-neighbor interation Heibenberg model on Page 101-104 ]</span></p><p><strong>Power-law decaying $C(r)\sim 1&#x2F;r, 0&lt;g&lt;g_c$</strong> in Heisenberg chain phase  $\to$  <strong>exponentially decaying</strong> with a triplet excitation gap in VBS phase. </p><p>The graph<span style="color: blue;">[ See ref.2 Fig.37 on Page 104 ]</span> shows directly how Spin correlations exponentially decay in VBS phase and how Dimer correlations $\sim 1&#x2F;r$ decay in Néel phase.  The black line(circles) correspond to the VBS phase.</p><p>This is similar to the KT transition.</p><p><strong>Kosterliz-Thouless transition</strong><span style="color: blue;">[ See ref.2: KT transition of 2D XY model on Page 51 ]</span></p><p>This is a <strong>thermodynamic phase transition</strong> (order to disorder). Although it has been proven that the ordered phase cannot be achieved as long as the temperature is limited<span style="color: blue;">[ References: J. M. Kosterlitz and D. J. Thouless, J. Phys. C 6, 1181 (1973).     J. M. Kosterlitz, J. Phys. C 7, 1046 (1974).     provided by ref.2 ]</span>, the correlation function shows <strong>power-law decaying $C(r)\sim r^{-\eta}, 0&lt;T&lt;T_{KT}$</strong>  $\to$  <strong>exponentially decaying.</strong></p><h3 id="Finite-size-scaling-and-critical-exponents-normal-cases"><a href="#Finite-size-scaling-and-critical-exponents-normal-cases" class="headerlink" title="Finite-size scaling and critical exponents. (normal cases)"></a>Finite-size scaling and critical exponents. (normal cases)</h3><p>Be careful about correlation length $\xi$ and correlation function $C$.  At the critical point, the behavior of $\xi$ is power law diverge: $\xi \sim |t|^{-\nu}$ where $t$ is reduced temperature or any other parameter about criticality. </p><p>The correlation at the critical point is:</p><p>$$<br>C(r) \sim r^{-(d-2 + \eta)}<br>$$</p><p>where $d$ is the space dimension in Classic system and $d \to d+1$ in Quantum system.<span style="color: blue;">[ See ref.2 mentioned the $d$-dimension lattice with time dimension mapped to $d+1$ spatial dimension, the only thing needed to do for quantum phase transition is directly replacing the $d$  $\to d+1$ of the scaling, on Page 54 ]</span>, which means, $C \sim r^{-(1+\eta)}$ in a usually 2D quantum critical point.</p><h2 id="Imaginary-time-correlation"><a href="#Imaginary-time-correlation" class="headerlink" title="Imaginary time correlation"></a>Imaginary time correlation</h2><p>[Hui Shao, A. W. Sandvik.  <a href="http://arxiv.org/pdf/2202.09870">arxiv.org&#x2F;pdf&#x2F;2202.09870</a>]</p><p>For the real time correlation:</p><p>$$<br>G(t) &#x3D; \langle S(t)S(0)\rangle<br>$$</p><p>Notice, $t &#x3D; 0$ is right means reacting first. While using Heisenberg picture $O(t) &#x3D; e^{iHt} O(t&#x3D;0) e^{-iHt}$, it becomes,</p><p>$$<br>G(t) &#x3D; \langle e^{iHt} S e^{-iHt}S\rangle<br>$$</p><p>to imaginary time $it \to \tau$, </p><p>$$<br>G(\tau &#x3D; it) &#x3D; \langle e^{H\tau} S e^{-H\tau}S\rangle<br>$$</p><p><span style="color: red;">be careful, $+\tau$ is on the left and $-\tau$ is on the right.</span>  </p><p>The dynamic spin structure factor $S(q,\omega)$ can be measured, e.g., by magnetic inelastic neutron scattering as the cross section for momentum $(q)$ and energy $(\omega)$ transfer. So according to,</p><p>$$<br>G(\tau) &#x3D; \int d\tau S(\omega)e^{-\omega \tau }<br>$$</p><p>we can obtain $S(\omega) \to G(\tau)$.   QMC also can and only can measure $G(\tau)$.   But more valuable is $G(\tau) \to S(\omega)$ which needs <strong>Stochastic analytic continuation</strong>(SAC).</p><p>The imaginary time correlation itself does not seem to have much information and behavior that needs to be discussed.</p><hr><h2 id="Correlation-entanglement-entropy"><a href="#Correlation-entanglement-entropy" class="headerlink" title="Correlation &amp; entanglement-entropy"></a>Correlation &amp; entanglement-entropy</h2><h3 id="topology"><a href="#topology" class="headerlink" title="topology"></a>topology</h3><p>The difference between entanglement entropy(EE) and two-point correlation function is:  topological EE.</p><p>Although entanglement entropy and correlation properties are similar, and there is also <strong>divergence behavior</strong> at the phase transition point, using the entropy quantity to measure the entanglement between sub-regions has an advantage compared to the traditional two-point correlation function</p><ul><li>For example, in spin liquid states, the two-point correlation function decays at large scales, but such states can exhibit topological order, quantified by topological EE.</li></ul><p>reference:</p><p>[1] n-lab. Correlator. Available at: <a href="https://ncatlab.org/nlab/show/correlator">https://ncatlab.org/nlab/show/correlator</a></p><p>[2] Sandvik. Computational Studies of Quantum Spin Systems.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Updating&lt;/p&gt;
&lt;h6 id=&quot;short-review-summary&quot;&gt;&lt;a href=&quot;#short-review-summary&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MPI1</title>
    <link href="http://example.com/2024/04/16/MPI1/"/>
    <id>http://example.com/2024/04/16/MPI1/</id>
    <published>2024-04-16T02:18:16.000Z</published>
    <updated>2024-04-16T02:20:56.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="幼儿园式使用MPI-in-Fortran-90"><a href="#幼儿园式使用MPI-in-Fortran-90" class="headerlink" title="幼儿园式使用MPI in Fortran 90"></a>幼儿园式使用MPI in Fortran 90</h1><h4 id="初步在程序中加入MPI"><a href="#初步在程序中加入MPI" class="headerlink" title="初步在程序中加入MPI"></a>初步在程序中加入MPI</h4><p>在你的 .f90 文件中，在主程序的开头，除了use module之后，引入MPI库  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;mpif.h&#x27;</span></span><br><span class="line"><span class="keyword">integer</span>:: processor_number, my_rank, ierr <span class="comment">!定义变量</span></span><br></pre></td></tr></table></figure><p>一定要定义这些变量，这些变量除了可以定义在这里也可以<strong>预先定义在全局变量的module中</strong>。 </p><p>在变量定义结束之后，一定要初始化MPI环境: After this, the MPI environment must be initialized with:(现在这些程序可以放在主程序变量命名后面以示MPI初始化.)  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! Initialize MPI. This must be the first MPI call</span></span><br><span class="line"><span class="keyword">call</span> MPI_Init(ierr)</span><br><span class="line"><span class="comment">! Get the individual process rank</span></span><br><span class="line"><span class="keyword">call</span> MPI_Comm_rank(MPI_COMM_WORLD,my_rank,ierr)</span><br><span class="line"><span class="comment">! Get the number of processes</span></span><br><span class="line"><span class="keyword">call</span> MPI_Comm_size(MPI_COMM_WORLD,processor_number,ierr)</span><br></pre></td></tr></table></figure><p><code>call MPI_Comm_rank</code> 用于获取当前进程的排名（或称为进程号）,  <code>processor_number</code> 相当于获取通信域中的进程总数目. 注意到，假如我们调用8个核，那么my_rank的值将会是:0,1,2,…7.   </p><pre><code>*但是在一个简单的print示例中，我们发现进程并不是按顺序的([from](https://www.dartmouth.edu/~rc/classes/intro_mpi/running_mpich2_ex.html#top)):</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t01:~&gt; mpiexec -n 8 hello_world_c</span><br><span class="line">Hello world from process 1 of 8</span><br><span class="line">Hello world from process 6 of 8</span><br><span class="line">Hello world from process 0 of 8</span><br><span class="line">Hello world from process 3 of 8</span><br><span class="line">Hello world from process 4 of 8</span><br><span class="line">Hello world from process 2 of 8</span><br><span class="line">Hello world from process 5 of 8</span><br><span class="line">Hello world from process 7 of 8</span><br></pre></td></tr></table></figure><p>使它保持顺序执行，这一点在后面会有介绍.</p><p>在主程序的最后, (通常是<code>call deallocate()</code> )的后面结束MPI进程:  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! No more MPI calls after Finalize</span></span><br><span class="line"><span class="keyword">call</span> MPI_FINALIZE(ierr)</span><br></pre></td></tr></table></figure><p><code>MPI_Finalize</code> is used to clean up the MPI environment. No more MPI calls can be made after this one.</p><p>必须有MPI环境的结束.</p><hr><h4 id="命令行窗口中使用MPI"><a href="#命令行窗口中使用MPI" class="headerlink" title="命令行窗口中使用MPI:"></a>命令行窗口中使用MPI:</h4><p>先编译后运行:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpif90 xxxx.f90 -o xxx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -np N ./xxx</span><br></pre></td></tr></table></figure><p>这里面的 N 就是你选择的核心数量.  不同的 MPI 编译的方式命令可能有些微的差别，在我们组里的工作站需要 <code>-o</code> 在 .f90 文件的后面.</p><hr><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><h4 id="MPI-Wtime"><a href="#MPI-Wtime" class="headerlink" title="MPI_Wtime"></a>MPI_Wtime</h4><p>想要计算程序运行的总时间，可以增加这两个程序.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my_rank==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">start_time = MPI_Wtime()</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!执行一些操作</span></span><br><span class="line"><span class="comment">!操作结束以后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (my_rank==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">spend_time = MPI_Wtime()-start_time</span><br><span class="line"><span class="built_in">write</span> (*,*) <span class="string">&quot;spend &quot;</span>, spend_time, <span class="string">&#x27; seconds.&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，事先肯定要先定义<code>start_time</code>, <code>spend_time</code>这些变量。</p><h4 id="MPI-Bcast"><a href="#MPI-Bcast" class="headerlink" title="MPI_Bcast"></a>MPI_Bcast</h4><p>Broadcasts a message from the process with rank “root” to all other processes of the communicator</p><p>将消息从排名为“root”的进程广播到通信器的所有其他进程  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> MPI_BCAST(buffer, <span class="built_in">count</span>, datatype, root, comm, ierr)</span><br></pre></td></tr></table></figure><p>one sending to all and all ranks.  </p><p>We sometimes need what is call a point-to-point communication. Calling <code>MPI_Send</code> and <code>MPI_Recv</code> will send and receive data to&#x2F;from a single receiver&#x2F;sender. 但在这里我就不看了.</p><h4 id="MPI-Barrier"><a href="#MPI-Barrier" class="headerlink" title="MPI_Barrier"></a>MPI_Barrier</h4><p>阻塞. 顾名思义, until all processes都调用了它；the call returns at any process only after all members of the communicator have entered the call。</p><p>可以看作是一个进程锁，将每个进程保持在一定的代码行，直到所有进程都到达了这条线</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World from process 0 of 4</span><br><span class="line">Hello World from process 1 of 4</span><br><span class="line">Hello World from process 2 of 4</span><br><span class="line">Hello World from process 3 of 4</span><br></pre></td></tr></table></figure><p>之前我们提到，进程不按顺序输出&#x2F;保存怎么办，只需要在循环中加入barrier，例如:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> a = <span class="number">0</span>,processor_number,<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> (a==my_rank) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>*,<span class="string">&quot;bin&quot;</span>,j,<span class="string">&quot;a==&quot;</span>,a,<span class="string">&quot;gives.&quot;</span> <span class="comment">!输出当下第几个bin是由第几个核所给的</span></span><br><span class="line">      <span class="keyword">call</span> writeresults(msteps,j) <span class="comment">!!</span></span><br><span class="line">   <span class="keyword">endif</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">call</span> mpi_barrier(mpi_comm_world,ierr)</span><br><span class="line"><span class="keyword">enddo</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin           9 a==           0 gives.</span><br><span class="line">bin           9 a==           2 gives.</span><br><span class="line">bin           9 a==           1 gives.</span><br><span class="line">bin           9 a==           3 gives.</span><br><span class="line">...</span><br><span class="line">bin           9 a==          48 gives.</span><br><span class="line">bin           9 a==          49 gives.</span><br></pre></td></tr></table></figure><h4 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a>MPI_Gather</h4><p>Gathers together values from a group of processes.</p><p>这个routine从每个处理器收集数据到一个root上，最终的结果按照排名顺序存储。每个处理器发送相同数量的项目。接收到的项目数量是由单个处理器发送的数量决定的，而不是聚合大小，但接收缓冲区必须声明为足以容纳所有数据的大小。</p><ul><li>这些数据按照发送进程的排名顺序存储</li><li>将所有进程的数据收集到根进程，只有根进程拥有所有数据</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> MPI_GATHER(<span class="keyword">data</span>,processor_number,MPI_datatype,recvdata,processor_number,MPI_datatype,root,MPI_COMM_WORLD, ierr)</span><br></pre></td></tr></table></figure><p>注意到，上面这个代码的换行只是因为写不下了，在合适的编辑器里是放得下的.</p><h3 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h3><h5 id="Dismatch"><a href="#Dismatch" class="headerlink" title="Dismatch"></a>Dismatch</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Rank mismatch between actual argument at (1) and actual argument at (2) ...&quot;</span></span><br></pre></td></tr></table></figure><p>you may just need to add the following flag to the compilerfile or makefile that sets everything up. 只需要在编译的后面加入这个指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ -fallow-argument-mismatch</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpif90 replica.f90 -o renyi -fallow-argument-mismatch</span><br></pre></td></tr></table></figure><h4 id="非正常终止"><a href="#非正常终止" class="headerlink" title="非正常终止"></a>非正常终止</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-----------------------------------------------------------------------&quot;</span></span><br><span class="line"><span class="string">&quot;mpirun detected that one or more processes exited with non-zero status, thus causing</span></span><br><span class="line"><span class="string">&quot;</span>the job to be terminated. The first process to <span class="keyword">do</span> so was:</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mpirun 检测到一个或多个进程以非零状态退出，从而导致作业终止。 这样做的第一个过程是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &quot;</span>Process name: [[45820,1],15]</span><br><span class="line">  <span class="string">&quot;Exit code:    2     退出代码：2(MPI 的退出代码几乎没有任何意义)</span></span><br><span class="line"><span class="string">&quot;</span>-----------------------------------------------------------------------<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>分析原因: 释放一个未申请的变量, 主线程申请了的, 其它没有(Dongxi Liu)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mpirun noticed that process rank 39 with PID 0 on node finestation exited on signal 6 (Aborted).&quot;</span></span><br><span class="line"><span class="string">&quot;mpirun 注意到 PID 为 0 的进程 39 在信号 6 上退出（已中止）。&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;--------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">&quot;</span>Primary job  terminated normally, but 1 process returned</span><br><span class="line"><span class="string">&quot;a non-zero exit code. Per user-direction, the job has been aborted.</span></span><br><span class="line"><span class="string">&quot;</span>主要作业正常终止，但 1 个进程返回非零退出代码。根据用户方向，作业已中止。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;--------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">&quot;</span>double free or corruption (out) 双层释放或损坏</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Program received signal SIGABRT: Process abort signal.&quot;</span></span><br></pre></td></tr></table></figure><h4 id="参考的网页教程"><a href="#参考的网页教程" class="headerlink" title="参考的网页教程:"></a>参考的网页教程:</h4><p><a href="https://www.mpich.org/static/docs/v3.1.3/www3/MPI_Bcast.html">Bcast的使用</a> </p><p><a href="https://wvuhpc.github.io/Modern-Fortran/40-MPI/index.html">一个比较全面的使用教程示例</a></p><p><a href="https://www.mpich.org/static/docs/latest/www3/MPI_Barrier.html">barrier的使用</a></p><p><a href="https://www.dartmouth.edu/~rc/classes/intro_mpi/array_search_example1.html#top">一个可能还不错的教程</a></p><p><a href="https://people.math.sc.edu/Burkardt/f_src/mpi/mpi.html">像是具有很多练习的教程</a></p><p><a href="https://learning.rc.virginia.edu/files/MPI_Guide_Fortran.pdf">一个仅有命令的总结</a></p><p>(虽然我没看)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;幼儿园式使用MPI-in-Fortran-90&quot;&gt;&lt;a href=&quot;#幼儿园式使用MPI-in-Fortran-90&quot; class=&quot;headerlink&quot; title=&quot;幼儿园式使用MPI in Fortran 90&quot;&gt;&lt;/a&gt;幼儿园式使用MPI in Fort</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>熵数据处理日志</title>
    <link href="http://example.com/2024/04/16/%E7%86%B5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2024/04/16/%E7%86%B5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-16T02:08:23.000Z</published>
    <updated>2024-04-16T02:09:14.196Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在用python处理比较大的数据文件，在这里写下处理数据的细节，算是一个处理数据的日志？</p><h4 id="每个bin按顺序输出每个核的数据，数据形式为对数"><a href="#每个bin按顺序输出每个核的数据，数据形式为对数" class="headerlink" title="每个bin按顺序输出每个核的数据，数据形式为对数"></a>每个bin按顺序输出每个核的数据，数据形式为对数</h4><p>由于我们是分配到了50个核上，因此，我们需要将数据处理，每50个数据分为一行，这样，每个核的数据就会横着排开，而竖着的将会是同一个核的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">per_bin</span>(<span class="params">x</span>):</span><br><span class="line">    datanew = x.reshape(-<span class="number">1</span>,<span class="number">50</span>) <span class="comment">#total rank = 50</span></span><br><span class="line">    <span class="keyword">return</span> datanew</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;Your path&#x27;</span>) <span class="comment">#here input path</span></span><br><span class="line">datanew = per_bin(data) </span><br><span class="line"></span><br><span class="line">bindata = np.zeros(<span class="number">10</span>) <span class="comment"># bin = 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bindata[i] = np.<span class="built_in">sum</span>(datanew[i,:]) <span class="comment"># sum rank for each bin</span></span><br><span class="line"></span><br><span class="line">bindata = bindata.reshape(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">mean = np.mean(bindata, axis=<span class="number">1</span>)</span><br><span class="line">std = np.std(bindata, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(mean,std)</span><br></pre></td></tr></table></figure><hr><h4 id="使用了-MPI-Gather-集中到-my-rank-0-上的数据处理"><a href="#使用了-MPI-Gather-集中到-my-rank-0-上的数据处理" class="headerlink" title="使用了 MPI_Gather 集中到 my_rank&#x3D;0 上的数据处理"></a>使用了 MPI_Gather 集中到 my_rank&#x3D;0 上的数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(<span class="string">&#x27;&#x27;</span>) <span class="comment">#here input path</span></span><br><span class="line"><span class="built_in">print</span>(data.size) <span class="comment"># must equals corenumber x corenumber x bin</span></span><br><span class="line"></span><br><span class="line">bindata = np.zeros(<span class="number">10</span>) <span class="comment"># bin = 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bindata[i] = np.<span class="built_in">sum</span>(data[i]) <span class="comment"># sum rank for each bin</span></span><br><span class="line"></span><br><span class="line">bindata = bindata.reshape(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(bindata)</span><br><span class="line"></span><br><span class="line">mean = np.mean(bindata, axis=<span class="number">1</span>)</span><br><span class="line">std = np.std(bindata, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(mean,std)</span><br></pre></td></tr></table></figure><p>当然，这是最理想的情况，在不太理想的情况时候输出的可能很多都是NaN，比如像下面这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[nan nan nan nan nan nan nan nan nan nan]]</span><br><span class="line">[nan] [nan]</span><br></pre></td></tr></table></figure><p>这当然是因为每个bin里有些数据是NaN，然后累加造成NaN，那么求均值和误差自然也是NaN.</p><p>(在第一种处理方法的各种试探下，我们已经得知是rank49NaN）</p><p>预计是每个bin的rank49的数据出现了问题，因此对数据做处理进行拆解可以使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savetxt(<span class="string">&#x27;savepath/bin1.dat&#x27;</span>,data[<span class="number">1</span>]) <span class="comment">#将第一个bin的数据单独提炼出来保存</span></span><br></pre></td></tr></table></figure><p>这样可以看这个bin的数据到底是哪个出现了NaN</p><p>有点麻烦的是，需要把总数据 enrg_total_mp.dat 先细分成10个bin，然后给每个bin的最后那个数据替换成单独跑出来的可用数据，然后再用python把10个bin按顺序缝合在一个数据文件里。由于数据文本太大，里面有很多冗余的 0，因此还要先把所有0数据剔除掉.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(<span class="string">&#x27;&#x27;</span>) <span class="comment">#here input path</span></span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin1.dat&#x27;</span>,data[<span class="number">0</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin2.dat&#x27;</span>,data[<span class="number">1</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin3.dat&#x27;</span>,data[<span class="number">2</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin4.dat&#x27;</span>,data[<span class="number">3</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin5.dat&#x27;</span>,data[<span class="number">4</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin6.dat&#x27;</span>,data[<span class="number">5</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin7.dat&#x27;</span>,data[<span class="number">6</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin8.dat&#x27;</span>,data[<span class="number">7</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin9.dat&#x27;</span>,data[<span class="number">8</span>])</span><br><span class="line">np.savetxt(<span class="string">&#x27;../bin10.dat&#x27;</span>,data[<span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>但是这么做太麻烦了，我们可以写一个循环，代码优化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    np.savetxt(<span class="string">f&#x27;../bin<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.dat&#x27;</span>, data[i])</span><br></pre></td></tr></table></figure><p>替换掉NaN数据后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">bin1data = np.loadtxt(<span class="string">&#x27;../bin1.dat&#x27;</span>)</span><br><span class="line">bin2data = np.loadtxt(<span class="string">&#x27;../bin2.dat&#x27;</span>)</span><br><span class="line">bin3data = np.loadtxt(<span class="string">&#x27;../bin3.dat&#x27;</span>)</span><br><span class="line">bin4data = np.loadtxt(<span class="string">&#x27;../bin4.dat&#x27;</span>)</span><br><span class="line">bin5data = np.loadtxt(<span class="string">&#x27;../bin5.dat&#x27;</span>)</span><br><span class="line">bin6data = np.loadtxt(<span class="string">&#x27;../bin6.dat&#x27;</span>)</span><br><span class="line">bin7data = np.loadtxt(<span class="string">&#x27;../bin7.dat&#x27;</span>)</span><br><span class="line">bin8data = np.loadtxt(<span class="string">&#x27;../bin8.dat&#x27;</span>)</span><br><span class="line">bin9data = np.loadtxt(<span class="string">&#x27;../bin9.dat&#x27;</span>)</span><br><span class="line">bin10data = np.loadtxt(<span class="string">&#x27;../bin10.dat&#x27;</span>)</span><br><span class="line">result.extend(bin1data)</span><br><span class="line">result.extend(bin2data)</span><br><span class="line">result.extend(bin3data)</span><br><span class="line">result.extend(bin4data)</span><br><span class="line">result.extend(bin5data)</span><br><span class="line">result.extend(bin6data)</span><br><span class="line">result.extend(bin7data)</span><br><span class="line">result.extend(bin8data)</span><br><span class="line">result.extend(bin9data)</span><br><span class="line">result.extend(bin10data)</span><br></pre></td></tr></table></figure><p>相当笨拙的批量导入的代码对吧？同样的，我们优化一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    bin_data = np.loadtxt(<span class="string">f&#x27;../bin<span class="subst">&#123;i&#125;</span>.dat&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但是这样相当于在重复覆盖 <code>bin_data</code> . 除此之外，我们发现，我们在这里就可以移除0元素.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bin_data = np.loadtxt(<span class="string">f&#x27;.../bin<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.dat&#x27;</span>)</span><br><span class="line">    bin_data = remove_zeros(bin_data)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.6157868669403181, 0.6069826740235577, ..., -0.46142682339620744, nan]</span><br></pre></td></tr></table></figure><p>可以看到这会儿最后的nan还没替换掉.</p><p>移除0之后我们需要将rank49的每个bin均值替换掉这里的NaN，指定替换掉数组的某个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换指定索引处的元素</span></span><br><span class="line">array[index_to_replace] = new_value</span><br></pre></td></tr></table></figure><p>我们进行预处理rank49之后，赋值给对应的bin：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index_to_replace = <span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bin_data = np.loadtxt(<span class="string">f&#x27;.../bin<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.dat&#x27;</span>) <span class="comment">#批量导入</span></span><br><span class="line">    bin_data = remove_zeros(bin_data) <span class="comment">#移除所有0</span></span><br><span class="line">    bin_data[index_to_replace] = binrankdata[i] <span class="comment">#替换指定的NaN</span></span><br><span class="line">    <span class="built_in">print</span>(bin_data)</span><br></pre></td></tr></table></figure><p>这样就完成所有替换了. </p><p>code总结在这里:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load data</span></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data.size) <span class="comment"># check是不是10个完整的bin</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    np.savetxt(<span class="string">f&#x27;.../bin<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.dat&#x27;</span>, data[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># load rank49 data    </span></span><br><span class="line">rankdata = np.loadtxt(<span class="string">&#x27;&#x27;</span>) <span class="comment"># here input path</span></span><br><span class="line"><span class="built_in">print</span>(data.size) <span class="comment">#check是不是10个完整的bin</span></span><br><span class="line"></span><br><span class="line">binrankdata = np.zeros(<span class="number">10</span>) <span class="comment"># bin = 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    binrankdata[i] = np.<span class="built_in">sum</span>(data[i]) <span class="comment"># sum rank for each bin</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_zeros</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x != <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index_to_replace = <span class="number">49</span></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bin_data = np.loadtxt(<span class="string">f&#x27;../bin<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.dat&#x27;</span>)</span><br><span class="line">    bin_data = remove_zeros(bin_data)</span><br><span class="line">    bin_data[index_to_replace] = binrankdata[i]</span><br><span class="line">result.extend(bin_data)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(result))</span><br><span class="line">np.savetxt(<span class="string">&#x27;../AAA.dat&#x27;</span>,result)</span><br></pre></td></tr></table></figure><p>我们如何使用这个文件呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">renyi = np.loadtxt(<span class="string">&#x27;../AAA.dat&#x27;</span>)</span><br><span class="line"></span><br><span class="line">datanew = renyi.reshape(-<span class="number">1</span>,<span class="number">50</span>) </span><br><span class="line"></span><br><span class="line">bindata = np.zeros(<span class="number">10</span>) <span class="comment"># bin = 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    bindata[i] = np.<span class="built_in">sum</span>(datanew[i,:]) <span class="comment"># sum rank for each bin</span></span><br><span class="line"></span><br><span class="line">bindata = bindata.reshape(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">mean = np.mean(bindata, axis=<span class="number">1</span>)</span><br><span class="line">std = np.std(bindata, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(mean,std)</span><br></pre></td></tr></table></figure><hr><h4 id="从输出数据文件中分离数据组"><a href="#从输出数据文件中分离数据组" class="headerlink" title="从输出数据文件中分离数据组"></a>从输出数据文件中分离数据组</h4><p>导入数据之后可能要先进行数据的分离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(<span class="string">&#x27;.../res.dat&#x27;</span>) <span class="comment"># 秋裤的输出数据文件</span></span><br><span class="line"><span class="comment"># if data = Jr, Jr_ratio, Wratio</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离四组数据</span></span><br><span class="line">data1 = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">data2 = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">data3 = [x[<span class="number">2</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里预先按50核reshape了jr,wratio</span></span><br><span class="line">data1 = np.array(data1).reshape(-<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">np.savetxt(<span class="string">&#x27;.../jr.dat&#x27;</span>,data1) </span><br><span class="line">data3 = np.array(data3).reshape(-<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">np.savetxt(<span class="string">&#x27;.../Wratio.dat&#x27;</span>,data3)</span><br></pre></td></tr></table></figure><p>这段代码使用了列表推导式来遍历 <code>data</code> 列表中的每个三元组，并从中提取出对应位置的元素，然后将这些元素分别存储到 <code>data1</code>、<code>data2</code> 和 <code>data3</code> 中。</p><p>具体来说，<code>[x[0] for x in data]</code> 中的列表推导式遍历 <code>data</code> 列表中的每个元素 <code>x</code>，并提取出其中的第一个元素（索引为0的元素），然后将这些第一个元素构成一个新的列表赋值给 <code>data1</code>。同样的方式，<code>[x[1] for x in data]</code> 和 <code>[x[2] for x in data]</code> 分别将三元组中的第二个和第三个元素提取出来，分别存储到 <code>data2</code> 和 <code>data3</code> 中</p><hr><h4 id="将100w个数据点按每个核的顺序排列并且每个bin中只提取一个数据"><a href="#将100w个数据点按每个核的顺序排列并且每个bin中只提取一个数据" class="headerlink" title="将100w个数据点按每个核的顺序排列并且每个bin中只提取一个数据"></a>将100w个数据点按每个核的顺序排列并且每个bin中只提取一个数据</h4><p>继续处理上面保存的数据文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(<span class="string">&#x27;.../jr.dat&#x27;</span>) <span class="comment">#导入jr</span></span><br><span class="line"><span class="built_in">print</span>(data.size) <span class="comment">#可以看一下数据组大小，比如10w份的话这里的数据组大小应该是100w</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">1</span>]) <span class="comment">#可以看一下50个核每个核的第2个数据</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">10</span>]) <span class="comment">#可以看一下50个核每个核的第11个数据</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[1.00000000e+00 8.18722565e-01 6.70306639e-01 5.48795171e-01</span><br><span class="line"> 4.49310990e-01 3.67861046e-01 3.01176140e-01 2.46579702e-01</span><br><span class="line"> 2.01880366e-01 1.65284011e-01 1.35321749e-01 1.10790970e-01</span><br><span class="line"> 9.07070671e-02 7.42639226e-02 6.08015492e-02 4.97796004e-02</span><br><span class="line"> 4.07556821e-02 3.33675966e-02 2.73188043e-02 2.23665215e-02</span><br><span class="line"> 1.83119759e-02 1.49924279e-02 1.22746390e-02 1.00495239e-02</span><br><span class="line"> 8.22777202e-03 6.73626261e-03 5.51513020e-03 4.51536155e-03</span><br><span class="line"> 3.69682839e-03 3.02667682e-03 2.47800861e-03 2.02880157e-03</span><br><span class="line"> 1.66102562e-03 1.35991916e-03 1.11339650e-03 9.11562841e-04</span><br><span class="line"> 7.46317068e-04 6.11026624e-04 5.00261285e-04 4.09575203e-04</span><br><span class="line"> 3.35328461e-04 2.74540978e-04 2.24772893e-04 1.84026640e-04</span><br><span class="line"> 1.50666763e-04 1.23354278e-04 1.00992931e-04 8.26851918e-05</span><br><span class="line"> 6.76962323e-05 5.54244330e-05]</span><br></pre></td></tr></table></figure><p>此时我们发现数据组print出来的结果，一个索引对应了50个数,这是因为我们之前是reshape之后保存的.  这样的输出结果，其实是因为 <code>print(data[1])</code> 就是 <code>print(data[1,:])</code> .</p><p>显然上面的方式我们会看到多个核的数据，如果只想查看一个核的数据，它的数据是列数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>): <span class="comment">#10w的情况下每个核跑了2000x10bin个数据</span></span><br><span class="line">    <span class="built_in">print</span>(data[i,<span class="number">0</span>]) <span class="comment">#查看第一列(第0列)</span></span><br></pre></td></tr></table></figure><p>这样就可以查看第一个核跑了对应的哪些jr.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9999</span><br><span class="line">0.9998000100000001</span><br><span class="line">0.9998000100000001</span><br><span class="line">0.9998000100000001</span><br><span class="line">0.9998000100000001</span><br><span class="line">...</span><br><span class="line">0.8188044457101201</span><br><span class="line">0.8188044457101201</span><br><span class="line">0.8188044457101201</span><br><span class="line">0.8188044457101201</span><br></pre></td></tr></table></figure><p>可以看到第二个核的第一个数据确实承接第一个核的最后一个数据. 0.818804 -&gt; 0.8187225</p><p>现在，我们利用第一节内循环的思想，单独提取每个核的那一列数据，并且将数据按核的顺序排列成一维数组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    datax = [x[i] <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">    result.extend(datax)</span><br></pre></td></tr></table></figure><p><code>.extend()</code>这个函数会将括号内的东西加到<code>result</code>的末尾，在这里，就是逐列提取然后排到末尾.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#rank0</span><br><span class="line">... #bin=1</span><br><span class="line">... </span><br><span class="line">... #bin=2</span><br><span class="line">...</span><br><span class="line">... #bin=10</span><br><span class="line"></span><br><span class="line">... #bin=1</span><br><span class="line">...</span><br><span class="line">... #bin=2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#rank1</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们最后还希望的是取10个bin里的某个数就可以，因为jr将作为横坐标，10个bin的数值是一模一样的。所以:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_data = data[::<span class="number">10</span>] <span class="comment">#每10个数据取一个数据保存到新的数组</span></span><br><span class="line">np.savetxt(<span class="string">&#x27;.../realjr.dat&#x27;</span>,new_data)</span><br></pre></td></tr></table></figure><p>这样就可以查看第一个核跑了对应的哪些jr.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br><span class="line">0.9999</span><br><span class="line">0.9998000100000001</span><br><span class="line">...</span><br><span class="line">0.8188044457101201</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下这里的code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#处理j2</span></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;.../jr.dat&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = [] <span class="comment">#准备一个空数组用来保存所有核按顺序排列的数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    datax = [x[i] <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">    result.extend(datax)</span><br><span class="line">    </span><br><span class="line">new_data = result[::<span class="number">10</span>] <span class="comment">#每10个数据取一个数据保存到新的数组</span></span><br><span class="line">np.savetxt(<span class="string">&#x27;.../realjr.dat&#x27;</span>,new_data)</span><br></pre></td></tr></table></figure><hr><h4 id="将100w个数据点按10个bin分好且bin内每个核的顺序排列"><a href="#将100w个数据点按10个bin分好且bin内每个核的顺序排列" class="headerlink" title="将100w个数据点按10个bin分好且bin内每个核的顺序排列"></a>将100w个数据点按10个bin分好且bin内每个核的顺序排列</h4><p>对于 wratio 的数据，最后我们想对10个bin做统计，而bin内部，这些核的数据是要相乘的！</p><p>通过以下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(<span class="string">&#x27;.../Wratio.dat&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data.size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化结果数组 这是两个中转数组</span></span><br><span class="line">result = np.zeros((<span class="number">20000</span>, <span class="number">50</span>)) <span class="comment"># here 2000x10bin=2w</span></span><br><span class="line">temp = np.zeros((<span class="number">2000</span>, <span class="number">50</span>)) <span class="comment">#10w 50core gives 2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        temp[i] = data[i*<span class="number">10</span>+j] <span class="comment">#注意到这里每隔10个数据，因为10bin</span></span><br><span class="line">    result[j*<span class="number">2000</span>:(j+<span class="number">1</span>)*<span class="number">2000</span>,:] = temp[:,:]</span><br></pre></td></tr></table></figure><p>这一步我们调换了核内部的数据顺序，使得不再是一个数据连续10个bin排列，而是10个bin每个bin内部数据连续排列.  外部循环访问每个数据的第1,2,3,..10个bin数据点，内部循环则是将这些散落的数据点排到同一个一维数组 <code>temp</code>.</p><p>我们可以得到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#rank0                  #rank1                  #rank2</span><br><span class="line">#第一个数据 #bin=1</span><br><span class="line">#第二个数据</span><br><span class="line">...</span><br><span class="line">#第一个数据 #bin=2</span><br><span class="line">#第二个数据</span><br><span class="line"></span><br><span class="line">..</span><br><span class="line">..#bin=10</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>但这还不算我们想要的，我们现在已经对每个核内部做了调整。我们希望把所有核的整合到一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ttemp = [] <span class="comment">#创建一个空数组，这是一个中转数组</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        datax = [x[i] <span class="keyword">for</span> x <span class="keyword">in</span> result[j*<span class="number">2000</span>:(j+<span class="number">1</span>)*<span class="number">2000</span>,:]]</span><br><span class="line">        ttemp.extend(datax)</span><br><span class="line"></span><br><span class="line">np.savetxt(<span class="string">&#x27;.../Wratio.dat&#x27;</span>,ttemp)</span><br></pre></td></tr></table></figure><p>这样我们就获得了一个想要Wratio的数据按照每个bin进行排序的文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> #bin=1</span><br><span class="line">... #rank0</span><br><span class="line">... </span><br><span class="line">... #rank1</span><br><span class="line">...</span><br><span class="line">... #rank49</span><br><span class="line"></span><br><span class="line">#bin=2</span><br><span class="line">... #rank0</span><br><span class="line">...</span><br><span class="line">... #rank1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>总结一下code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理Zblank</span></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;.../Zblank.dat&#x27;</span>) <span class="comment">#这一步需要的数据文件一定要是预先reshape(-1,50)过的</span></span><br><span class="line"><span class="built_in">print</span>(data.size) <span class="comment">#可以看一下数据组大小，比如10w份的话这里的数据组大小应该是100w</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 初始化结果数组</span></span><br><span class="line">result = np.zeros((<span class="number">20000</span>, <span class="number">50</span>))</span><br><span class="line">temp = np.zeros((<span class="number">2000</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        temp[i] = data[i*<span class="number">10</span>+j]</span><br><span class="line">    result[j*<span class="number">2000</span>:(j+<span class="number">1</span>)*<span class="number">2000</span>,:] = temp[:,:]</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>:<span class="number">2000</span>,<span class="number">0</span>])    </span><br><span class="line"></span><br><span class="line">ttemp = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        datax = [x[i] <span class="keyword">for</span> x <span class="keyword">in</span> result[j*<span class="number">2000</span>:(j+<span class="number">1</span>)*<span class="number">2000</span>,:]]</span><br><span class="line">        ttemp.extend(datax)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ttemp))</span><br><span class="line">np.savetxt(<span class="string">&#x27;.../testZblank.dat&#x27;</span>,ttemp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取中转文件</span></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;.../testZblank.dat&#x27;</span>) <span class="comment">#===Zblank input</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片成10份</span></span><br><span class="line">slices = np.array_split(data, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每份内部元素相乘后的结果</span></span><br><span class="line">Zblank = [np.prod(<span class="built_in">slice</span>) <span class="keyword">for</span> <span class="built_in">slice</span> <span class="keyword">in</span> slices] <span class="comment">#===Zblank</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>*np.log(Zblank))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天在用python处理比较大的数据文件，在这里写下处理数据的细节，算是一个处理数据的日志？&lt;/p&gt;
&lt;h4 id=&quot;每个bin按顺序输出每个核的数据，数据形式为对数&quot;&gt;&lt;a href=&quot;#每个bin按顺序输出每个核的数据，数据形式为对数&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo网站修改字体修改日志</title>
    <link href="http://example.com/2024/04/03/Hexo%E7%BD%91%E7%AB%99%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2024/04/03/Hexo%E7%BD%91%E7%AB%99%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-03T06:41:00.000Z</published>
    <updated>2024-04-03T06:43:08.194Z</updated>
    
    <content type="html"><![CDATA[<p>Main.css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    margin-top: 56px;</span><br><span class="line">    color: var(--black-2);</span><br><span class="line">    background-color: var(--body-bg);</span><br><span class="line">    font-family: &quot;SF Pro Display&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    margin-top: 56px;</span><br><span class="line">    color: var(--black-2);</span><br><span class="line">    background-color: var(--body-bg);</span><br><span class="line">    font-family: &quot;Courier&quot;, &quot;SF Pro Display&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只有这个管用了，在主题文件里. 通过搜索 font 搜索出来.</p><p>其它更改(但没有起作用)</p><p>_extend.styl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-style: italic -&gt; font-style: courier</span><br></pre></td></tr></table></figure><p>_variables.styl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Fonts</span><br><span class="line">font-sans = &quot;Courier&quot;, -apple-system, BlinkMacSystemFont,</span><br><span class="line">    &quot;Segoe UI&quot;, &quot;Roboto&quot;, &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;,</span><br><span class="line">    &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;,</span><br><span class="line">    sans-serif</span><br><span class="line">font-serif = Georgia, &quot;Times New Roman&quot;, serif</span><br><span class="line">font-mono = &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line">// Fonts</span><br><span class="line">font-sans = &quot;Courier&quot;, -apple-system, BlinkMacSystemFont,</span><br><span class="line">    &quot;Segoe UI&quot;, &quot;Roboto&quot;, &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;,</span><br><span class="line">    &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;,</span><br><span class="line">    sans-serif</span><br><span class="line">font-serif = &quot;Courier&quot;, Georgia, &quot;Times New Roman&quot;, serif</span><br><span class="line">font-mono = &quot;Courier&quot;, &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace</span><br></pre></td></tr></table></figure><p>article.styl</p><p>style.styl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">  background: color-background</span><br><span class="line">  font: font-size font-sans</span><br><span class="line">  -webkit-text-size-adjust: 100%</span><br></pre></td></tr></table></figure><p>fontStyle.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var valid_styles = [&#x27;normal&#x27;, &#x27;italic&#x27;, &#x27;oblique&#x27;, &#x27;inherit&#x27;];</span><br><span class="line">-&gt;</span><br><span class="line">var valid_styles = [&#x27;courier&#x27;, &#x27;normal&#x27;, &#x27;italic&#x27;, &#x27;oblique&#x27;, &#x27;inherit&#x27;];</span><br></pre></td></tr></table></figure><p>iconic.styl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iconic-stroke(path)</span><br><span class="line">  @font-face</span><br><span class="line">    font-family: &#x27;IconicStroke&#x27;</span><br><span class="line">    src: url(path + &#x27;/iconic_stroke.eot&#x27;)</span><br><span class="line">    src: local(&#x27;☺&#x27;), url(path + &#x27;/iconic_stroke.ttf&#x27;) format(&#x27;truetype&#x27;), url(path + &#x27;/iconic_stroke.svg#iconic&#x27;) format(&#x27;svg&#x27;)</span><br><span class="line">    font-weight: normal</span><br><span class="line">    font-style: normal</span><br><span class="line">-&gt;</span><br><span class="line">iconic-stroke(path)</span><br><span class="line">  @font-face</span><br><span class="line">    font-family: &#x27;Courier&#x27;</span><br><span class="line">    src: url(path + &#x27;/iconic_stroke.eot&#x27;)</span><br><span class="line">    src: local(&#x27;☺&#x27;), url(path + &#x27;/iconic_stroke.ttf&#x27;) format(&#x27;truetype&#x27;), url(path + &#x27;/iconic_stroke.svg#iconic&#x27;) format(&#x27;svg&#x27;)</span><br><span class="line">    font-weight: normal</span><br><span class="line">    font-style: normal</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Main.css&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>testlatex</title>
    <link href="http://example.com/2024/03/27/testlatex/"/>
    <id>http://example.com/2024/03/27/testlatex/</id>
    <published>2024-03-27T03:56:22.000Z</published>
    <updated>2024-03-27T04:45:13.639Z</updated>
    
    <content type="html"><![CDATA[<p>在themes里配置好 mathjax 的环境之后，最好在 博客.md 的顶部追加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line"><span class="built_in">date</span>: 2020-09-02 20:11:42</span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>现在无论是居中公式:</p><p>$$<br>-\ln \langle  \frac{g(t_m)}{g(t_i)} \rangle_{\text{each rank}} \<br>$$</p><p>$$<br>\sum_{\text{rank 0}}^{50} -\ln  \langle \frac{g(t_m)}{g(t_i)} \rangle &#x3D; -\ln \langle \frac{g(t_m)}{g(t_i)} \rangle_{\text{each bin}}<br>$$</p><p>Finally, we will get 10 bin data.</p><p>ZJR old MPI:<br>$$<br>\text{each rank } \prod_t \langle \frac{g(t+\delta)}{g(t)} \rangle \ \ -\text{enrg1} \<br>\text{all rank } \prod_r \langle \frac{g(t+\delta)}{g(t)} \rangle<br>$$</p><hr><p>Benchmark from…</p><p>还是行内公式 都可以正常识别了.</p><p>Two dimensional $L\times L&#x2F;2$ Heisenberg model, region A is chosen to be $L&#x2F;2 \times L&#x2F;2$ without corners. The temperatures are chosen to be $1&#x2F;T &#x3D; L$.</p><p>The fitting result is:<br>$$<br>\color{yellow }{S^2(A) &#x3D; 0.092 L + 1.00\ln L -1.63}<br>$$<br>gives &#x3D;&#x3D;<strong>2.6145</strong>&#x3D;&#x3D; for $8 \times 16$ Lattice and &#x3D;&#x3D;<strong>1.18544</strong>&#x3D;&#x3D; for $4 \times 8$ Lattice.</p><p>Reference:</p><p><a href="https://blog.xiangfa.org/2020/09/let-hexo-support-latex-formulas/">https://blog.xiangfa.org/2020/09/let-hexo-support-latex-formulas/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在themes里配置好 mathjax 的环境之后，最好在 博客.md 的顶部追加：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>testpdf</title>
    <link href="http://example.com/2024/03/27/testpdf/"/>
    <id>http://example.com/2024/03/27/testpdf/</id>
    <published>2024-03-27T03:18:35.000Z</published>
    <updated>2024-03-27T03:42:43.717Z</updated>
    
    <content type="html"><![CDATA[<p>测试插入pdf</p><p>blog 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-pdf --save</span><br></pre></td></tr></table></figure><p>使用 <code>Hexo n &#39;blogname&#39;</code> 正常创建博客.   在 Source 文件夹中多出 .md 文件和对应的文件夹.</p><p>将要展示的pdf放到文件夹中，在 .md 文件中引用：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 引用文档名字.pdf %&#125;</span><br></pre></td></tr></table></figure><p>(总感觉这种显示方式不是特别好)</p><div class="row">    <embed src="testpdf.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试插入pdf&lt;/p&gt;
&lt;p&gt;blog 目录下执行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bond-spin basis update</title>
    <link href="http://example.com/2024/03/05/Bond-spin-basis-update/"/>
    <id>http://example.com/2024/03/05/Bond-spin-basis-update/</id>
    <published>2024-03-05T07:30:51.000Z</published>
    <updated>2024-03-05T09:06:22.609Z</updated>
    
    <content type="html"><![CDATA[<p>两个VBS态如图所示.</p><p><img src="/2024/03/05/Bond-spin-basis-update/image-20240305153630797-1.png" alt="Fig 1"></p><p>所有的“bond”只是两两链接，因此一个态上全是singlet，且只有singlet. 一个singlet就是自旋单重态：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:2"><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">(</mo><mrow data-mjx-texclass="INNER"> <mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"> <mo stretchy="false">&#x2191;&#x2193;</mo></mrow> <mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>&#x2212;</mo><mrow data-mjx-texclass="INNER"> <mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2193;&#x2191;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo stretchy="false">)</mo></mtd></mlabeledtr></mtable></math><br>对于这样的两个VBS态做内积，一些“bond”将会连成loop.</p><p><img src="/2024/03/05/Bond-spin-basis-update/image-20240305161832755-1.png" alt="Fig 2"></p><p>然而，VBS basis的内积结果将与能形成的Loop有关，与<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mi>z</mi></msub></math>表象下自旋朝向的兼容度也有关，因此VBS basis是不正交的，任意两个VBS态内积给出不同的值。</p><p>为了避免这一点，将VBS basis看作是bond-spin basis，我们采用分步更新的方式</p><p><img src="/2024/03/05/Bond-spin-basis-update/image-20240305161718549-1.png" alt="Fig 3"></p><p>Swap operator将两种态的A进行互换，环境<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mover><mi>A</mi><mo stretchy="false">&#xAF;</mo></mover></mrow></math>不变。在切的边界上，一些互换就会“藕断丝连”，因此可以看成是一种双层结构。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><strong><a href="https://arxiv.org/abs/2402.17211"> arXiv:2402.17211</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两个VBS态如图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/03/05/Bond-spin-basis-update/image-20240305153630797-1.png&quot; alt=&quot;Fig 1&quot;&gt;&lt;/p&gt;
&lt;p&gt;所有的“bond”只是两两链接，因此一个态上</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>use anaconda</title>
    <link href="http://example.com/2024/03/02/use-anaconda/"/>
    <id>http://example.com/2024/03/02/use-anaconda/</id>
    <published>2024-03-02T02:23:34.000Z</published>
    <updated>2024-03-02T03:17:50.976Z</updated>
    
    <content type="html"><![CDATA[<p>这里默认已经在电脑上下载了Anaconda (for Mac M1&#x2F;M2)</p><p>先将anaconda配置到系统路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$echo &#x27;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">$source ~/.bashrc</span><br></pre></td></tr></table></figure><p>这里假设安装的是anaconda3版本</p><p>通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda -v</span><br></pre></td></tr></table></figure><p>查看安装结果、安装版本号</p><hr><p>题外话</p><p>自从安装了zsh之后一直没用iTerm使用conda指令，昨天用conda指令突然发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: command not found: conda</span><br></pre></td></tr></table></figure><p>在网上查找解决方法，似乎是因为zsh里没有加入conda的path。</p><p>解决方法有几种。</p><p>第一种，在zsh中增加conda的path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">按i进入编辑模式，在文件末尾添加:</span><br><span class="line">$export PATH=/Users/[your name]/anaconda3/bin:$PATH</span><br><span class="line"></span><br><span class="line">按Esc退出编辑模式, :wq 来退出</span><br><span class="line"></span><br><span class="line">$source ~/.zshrc</span><br><span class="line"></span><br><span class="line">重启zsh</span><br><span class="line">$exec /bin/zsh</span><br></pre></td></tr></table></figure><p>我发现并没有操作成功，zsh仍然显示not found，可能我之后会知道原因。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/用户名/.zshrc:113: ... not found</span><br></pre></td></tr></table></figure><p>第二种，是在系统自带的终端中设置</p><p>设置 &#x3D;&gt; 通用 &#x3D;&gt; shell的打开方式：</p><p>把</p><p>​“默认登陆shell”</p><p>改成</p><p>​“命令（完整的路径）:</p><p>​&#x2F;bin&#x2F;bash”</p><p>安装了zsh后默认是 &#x2F;bin&#x2F;zsh，改成&#x2F;bin&#x2F;bash相当于系统自带的终端不用zsh，就可以恢复到正常使用。</p><p>iTerm依然用的是zsh.</p><p>参考解决方式：</p><p><a href="https://stackoverflow.com/questions/18428374/in-mac-always-getting-zsh-command-not-found">https://stackoverflow.com/questions/18428374/in-mac-always-getting-zsh-command-not-found</a></p><p><a href="https://www.jianshu.com/p/13f5d20e61f8">https://www.jianshu.com/p/13f5d20e61f8</a></p><p><a href="https://zhuanlan.zhihu.com/p/86688024">https://zhuanlan.zhihu.com/p/86688024</a></p><p>可能有别的解决方法，但是我用第二种解决方法解决了，先这么用着。（第二种解决方法来自第一条链接）</p><hr><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>自路径配置成功之后，用户名前面会多一个(base)的字样，表明现在在conda的base环境下。在该环境下避免下载一些乱七八糟的东西以至于臃肿。</p><p>新配置一个环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda create --name &lt;env_name&gt; &lt;package_names&gt;</span><br></pre></td></tr></table></figure><p>比如说新建一个房间叫test，并且安装python3，可以有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda create -n test python=3.11  numpy pandas</span><br></pre></td></tr></table></figure><p>在这后面的表明同时把 numpy pandas 给装上了。</p><p>在base下查看现在有哪些环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda info -e</span><br></pre></td></tr></table></figure><p>正常情况下可以看到一个base，和刚才新建好的test</p><p>在base下删除一个环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda remove -n &lt;env_name&gt; --all</span><br></pre></td></tr></table></figure><p>就可以“一键删除”</p><p>如何进入到test的环境，conda采用激活的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda activate test</span><br></pre></td></tr></table></figure><p>用户名前面的(base)变成(test)说明进入环境成功了</p><p>查看该环境下有哪些安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda list</span><br></pre></td></tr></table></figure><p>在该环境下安装新的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda install &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>或者用pip:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pip3 install &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>​给指定环境安装包只能用conda：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda install -n &lt;env_name&gt; &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>卸载安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span><br><span class="line">or</span><br><span class="line">$conda remove &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>最后，退出该房间，回到base</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$conda deactivate</span><br></pre></td></tr></table></figure><p>不用加后缀名.</p><p>参考教程：</p><p><a href="https://www.jianshu.com/p/81f1dd1afb84">https://www.jianshu.com/p/81f1dd1afb84</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里默认已经在电脑上下载了Anaconda (for Mac M1&amp;#x2F;M2)&lt;/p&gt;
&lt;p&gt;先将anaconda配置到系统路径&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DL1</title>
    <link href="http://example.com/2024/02/18/DL1/"/>
    <id>http://example.com/2024/02/18/DL1/</id>
    <published>2024-02-18T02:35:59.000Z</published>
    <updated>2024-08-04T12:14:13.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Directed-Loop-I"><a href="#Directed-Loop-I" class="headerlink" title="Directed Loop I"></a>Directed Loop I</h1><p>写在前面：本文是我最近想要写XXZ+hz+hx Model的思考，顺带着复习、回顾DL.  大量参考了Syljuåsen, O. F. 关于DL的两篇文章，即2003年的<em>The Directed‐Loop Algorithm</em>和2003年的<em>Directed loop updates for quantum lattice models</em>.  其中第一篇可以看作是他和Sandvik合作的DL原文献的简略版.</p><h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><p>这里简单概述一下DL从何而来，以及为什么需要用到DL.</p><p>环算法(Loop algorithms)在世界线(world-line)量子蒙特卡罗计算中的应用及其在解决特定问题上的局限性。首先，环算法显著提高了世界线量子蒙特卡罗计算的性能，可以将自相关时间减少几个数量级，但传统环更新(conventional loop updates)受限于特定模型和参数空间.    特别是，在构建环的时候无法考虑外部场，并且环的翻转取决于Metropolis接受&#x2F;拒绝步骤。在高场下，大环的接受概率很小，因此此方法仅在高温或非常弱的场下可行。[^ 1]     </p><ul><li>Loop algorithm目前有许多限制，依赖于具体的模型和模型的参数，在低温或者强场的情况下发挥不好.</li></ul><p>最近的蠕虫算法(worm algorithm)和SSE算符-环算法(operator-loop algorithm for stochastic series expansion (SSE))的泛化克服了这个问题，允许环自相交(selfintersect)(我也不太知道这个翻译准不准)和回溯(backtrack)，从而考虑了复杂的相互作用和外部场。</p><p>SSE的早期应用中，local off-diagonal updates涉及同时将两个算符进行替换, 即$[1,b(p)][1,b(p’)] \longleftrightarrow [2,b(p)][2,b(p’)]$.   现在有DL，通过局域细致平衡条件，导致了始终接受的封闭loop的有效配置. [^ 2]</p><h5 id="有向环-DL-可以看作是由-vertex类型-DL方程-loop构建方式-组成"><a href="#有向环-DL-可以看作是由-vertex类型-DL方程-loop构建方式-组成" class="headerlink" title="有向环(DL)可以看作是由 vertex类型+DL方程+loop构建方式 组成."></a>有向环(DL)可以看作是由 vertex类型+DL方程+loop构建方式 组成.</h5><p>在有向环(DL)方案中，细致平衡条件导致了一组耦合的方程，用于描述各种构建loop（或蠕虫）步骤的概率。这些有向环方程通常有无穷多解，因此需要进行优化。有向循环算法最初是为SSE（Stochastic Series Expansion）开发的，但在同一篇文章中也介绍了对离散和连续虚时间中的世界线的适应性。</p><ul><li><p>对于给定的$S&#x3D;1&#x2F;2$海森堡模型的SSE算法.     选择合适的参数使得对角算符只作用于自旋相反的算符，令另外两种vertex权重为零.   loop路过两次的算符将保持不变。由于所有bond算符的非零矩阵元都等于1&#x2F;2，新配置的权重与旧配置完全相同，因此loop flip总是可以接受的。这种类型的环是通过构建而避免自交(self-avoiding)的（环不能有相交）。因此，配置也可以被分解为它的所有环（每个自旋属于恰好一个环），它们以1&#x2F;2的概率独立于彼此翻转，就像经典的Swendsen-Wang算法.  但这种确定的loop明显依赖于$\Delta &#x3D; 1,h&#x3D;0$.  证明DL其实是比SSE更普适的算法</p></li><li><p>想象DL loop的构建可以想象这些vertex通过vertexlist连接，因为虚时间上自旋的“线”的信息是冗余的</p></li><li><p>这个不连续性不是在于起点翻不翻的vertex类型允许不允许，而是在于（起点和终点）这些腿现在将链接到具有不同自旋的腿。[^ 3] 换句话说，就是一个配置，如果某个格点在虚时间上的自旋不满足周期性边界条件，这样的配置是不被允许，不对配分函数产生贡献的</p></li></ul><p>DL方程构建方式如下：首先，为通过vertex的所有可能路径分配未知权重$a$。所有这些路径权重在所有出口上（同一个入口）的总和必须等于裸vertex权重.[^ 4] 关键点还在于，**局部细致平衡(local detailed balance)**，要求构成彼此相反的vertex路径的权重必须相等，即，如果通过vertex k的路径i → e在翻转入口和出口自旋后导致vertex k’，那么通过k’的反向路径e → i会产生vertex k且路径权重相等[^ 5]</p><p><strong>目前没有找到寻找最优解的严格方法</strong>，但已提出一些启发式的论点：合理的假设是，反弹过程的概率应该最小化，因为它们不完成任何vertex变化，并导致环构建过程回溯一步（有时在环构建过程中方向相反时回溯一步以上）。</p><p>然而，DL的方程组实际上是给提供了追求无反弹（或者最优解）的数学框架，追求无反弹或者反弹很少的解，在于追求算法的自关联时间更少.  对于某些模型，<u>最小化反弹的解反而可能不是最优策略</u>.[^ 6] 因此，vertex和各路径权重拿到手之后，首要做的事也许不是思考怎么列方程，而是如何设计算符、如何构造一个loop，How to start? How to end?.</p><hr><p>Loop 的构建过程</p><h4 id="link-discontinuities-链接不连续性"><a href="#link-discontinuities-链接不连续性" class="headerlink" title="link-discontinuities 链接不连续性"></a>link-discontinuities 链接不连续性</h4><p>改变入口腿或退出腿的状态，或者同时改变两者，将导致一个或两个“链接不连续性”，即属于同一链接的不同腿上的状态不同。具有链接不连续性的配置不会对分区函数产生贡献，因此必须重复该过程，直到配置不再存在链接不连续性。</p><p>为了不引入更多的链接不连续性，下一个vertex入口腿的自旋状态受限于与之前退出腿的自旋状态相同，因此，前一个退出腿和当前入口腿之间的链接不连续性得以消除，然而，新退出腿的状态更改将引入新的链接不连续性，因此链接不连续性相当于是在路径前移动。</p><ul><li>出口腿自旋状态与下一个vertex的入口腿状态相同，且出口腿自旋翻转时，下一个vertex的入口腿自旋必须翻转</li><li>不连续性不能产生于路径中间，路径中途没有不连续性</li></ul><p>因此，在 Syljuåsen, O. F. (2003) 这篇文章中提到，若是出口腿没有翻转，那么下一个vertex入口腿也就不用翻转[^ 7]</p><p>当没有这样的守恒定律[^ 7]时，只因为尽管入口腿状态已经改变，退出腿状态没有改变时，一个链接不连续性可以消失，然后，如果在此步骤之前只有一个链接不连续性存在，可以终止该路径。这可以通过要求初始入口腿上没有链接不连续性来实现[^ 8][^ 9].</p><p>由于文献中提了一嘴“要求入口腿没有链接不连续性”，我们这里就顺便讲一下Henelius, P. 2002这篇文章</p><p><u>横场导致的非守恒定律.</u> ——以 Henelius, P. 2002 这篇文章为例</p><p>现在可以有只翻转一个自旋的更新方式，要么是出口腿要么是入口腿. 注意到在上段中提到了“终止”的说法，显然这并不是单格点算符的特权.</p><p>单个翻转顶点的引入或去除会改变链接不连续性的数量，如果选择以与无横场的方式相同的方式启动和结束循环，则循环可以在未纠正初始不连续性的情况下关闭（若终止腿无不连续性则闭合后无法和初始的不连续性湮灭，独留一个初始的不连续性）. 因此，Henelius, P. 继续设定，<u>起点是不翻转的</u>，这样开始一个loop。</p><p>其后果就是，若起点是以不翻转开始的，那么出口在翻或不翻的选择下，选到翻，这个不连续性经由下一个vertex的入口处必须翻转，这样的话该不连续性湮灭，取决于下一个vertex的出口到底翻不翻，翻则不连续性传播；不翻则无不连续性，loop可以在终止了.  当遇到终点是翻转自旋回到原点的时候，意识到初始的vertex是还是单自旋翻转的vertex，此时我们决定跟随终点翻转传播不连续性至起点，将原来不翻转的起点给翻了，这样新出来一个不连续性和终点的不连续性互相湮灭. 这样的话，闭合的loop实际上和之前起点翻、终点翻的loop是没有区别的，<u>总的来说因为人为假设起点不翻，只是多了一种在中途停止的可能性”string”</u>.</p><hr><p>代码实现的部分讲解</p><h4 id="Technical-details-技术细节"><a href="#Technical-details-技术细节" class="headerlink" title="Technical details 技术细节"></a>Technical details 技术细节</h4><h5 id="局部更新之对角更新"><a href="#局部更新之对角更新" class="headerlink" title="局部更新之对角更新"></a>局部更新之对角更新</h5><p>(和YZ聊了一下这么做应该是没问题的，之后再写进去)</p><h5 id="Loop更新"><a href="#Loop更新" class="headerlink" title="Loop更新"></a>Loop更新</h5><p>从随机选一个腿开始</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="comment">!select random vertex&#x27;s leg</span></span><br><span class="line">   v0=<span class="built_in">int</span>(ran()*(mm))*<span class="number">4</span>+<span class="built_in">int</span>(<span class="number">4.0</span>*ran())</span><br><span class="line">   <span class="keyword">if</span>(vertexlist(v0)&gt;=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">enddo</span> <span class="comment">!end select</span></span><br></pre></td></tr></table></figure><p>判断起点vertex是site vertex还是bond vertex，是后者的话当一端遇到site end时需要另起.</p><p>我们将引入一个判断，如果是site start，记为-2，如果是bond start，记为-1.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v3=-<span class="number">2</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">mod</span>(opstring(v0/<span class="number">4</span>),<span class="number">4</span>)==<span class="number">1</span> .or. <span class="built_in">mod</span>(opstring(v0/<span class="number">4</span>),<span class="number">4</span>)==<span class="number">2</span>) v3=-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>XXZ中的退出方式无非是两种</p><img src="/Users/wtake1/Library/Application Support/typora-user-images/image-20240223144106026.png" alt="image-20240223144106026" style="zoom: 33%;"><p>以短箭头为出发点，(a)是通过v1&#x3D;vertexlist(v2)纵向连接，并发现v1&#x3D;v0来退出</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((v1==v0).and.(n/=<span class="number">1</span>)) <span class="keyword">then</span></span><br></pre></td></tr></table></figure><p>(b)是通过v1连到了起点bond vertex之后，又一次执行了路径判断，发现v2 &#x3D; ir(ieor(v1,1)) &#x3D;&#x3D; v0来退出.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v2==v0) <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>这在构建过程中已经实现.</p><p>我们分别考察两种闭合方式中的自旋翻转和算符类型更改。</p><p>![image-20240224173314052](&#x2F;Users&#x2F;wtake1&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240224173314052.png)</p><p>![image-20240224173329844](&#x2F;Users&#x2F;wtake1&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240224173329844.png)</p><p>在程序中我们是通过v2, v1&#x3D;vertexlist(v2)绕过边界来实现连接的“这一段”之间的自旋翻转的，因此，起点出发作为起点本身的自旋是没有翻转的，对于(a)相当于是最后一段的自旋翻转“推”到了起点，引起了起点的自旋翻转；对于(b)起点本来也没有翻转，</p><p>程序主体:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> ...<span class="comment">!for MCStep</span></span><br><span class="line"><span class="comment">! 怎样算一个MC步由自己定义，目前来讲是通过fixed Loop number来退出:</span></span><br><span class="line">l = l+<span class="number">1</span> <span class="comment">! 完成的loop计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a random vertex<span class="string">&#x27;s leg v0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   v1=v0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">do !for makeloop of v0</span></span><br><span class="line"><span class="string"> !now we deal with v1</span></span><br><span class="line"><span class="string">   i=v1/4 !add</span></span><br><span class="line"><span class="string">   op=opstring(i)</span></span><br><span class="line"><span class="string">   b=op/4 !this cant distinct the bond or site</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   !(a)种退出的情况: 一定在已经翻转v2,v1=vertexlist(v2)路段之后</span></span><br><span class="line"><span class="string">   if((v1==v0).and.(n/=1)) exit</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   if(    ) then !进行v1所在vertex类型的判断</span></span><br><span class="line"><span class="string">   !根据入口、概率决定去向</span></span><br><span class="line"><span class="string">   v2 = ..</span></span><br><span class="line"><span class="string">   v1 = vertexlist(v2)</span></span><br><span class="line"><span class="string">   n = n+1</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   !(b)种退出的情况</span></span><br><span class="line"><span class="string">   if (v2==v0) exit</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   endif</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   !翻转自旋</span></span><br><span class="line"><span class="string">   !在这里仅翻转对周期性边界上自旋会产生影响的路段</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">  b=opstring(v2/4)/4 !这里假设b = op/4</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      if (mod(v2,4)&gt;1) then !*判断v2在上面两条腿</span></span><br><span class="line"><span class="string">         if (v2&gt;v1) then</span></span><br><span class="line"><span class="string">            s1=bsites(mod(v2,4)-1,b) !* bsites(1,b) or bsites(2,b)</span></span><br><span class="line"><span class="string">            spin(s1)=-spin(s1) </span></span><br><span class="line"><span class="string">         endif</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      else !*或者v2是下面两条腿</span></span><br><span class="line"><span class="string">         if (v2&lt;v1) then !*且v2在作为纵向跳转的v1的下面</span></span><br><span class="line"><span class="string">            s1=bsites(mod(v2,4)+1,b) !* 也就是 i or j</span></span><br><span class="line"><span class="string">            spin(s1)=-spin(s1) </span></span><br><span class="line"><span class="string">         endif</span></span><br><span class="line"><span class="string">      endif</span></span><br><span class="line"><span class="string"> enddo</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> if(l&gt;=20) exit !用来退出loop构造</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> enddo !for end MCStep</span></span><br><span class="line"><span class="string">   </span></span><br></pre></td></tr></table></figure><p>现在我们知道程序中实际上未对v0所在的腿进行翻转的处理. 但依然在两种闭合方式下符合.</p><p>仿照这样的处理方式，我们引入site算符，并且使用热浴解出的概率.</p><p>[^ 1]: In particular, external fields cannot be taken into account when constructing a loop, and the loop-flip is then conditional upon a subsequent Metropolis accept&#x2F;reject step. The acceptance probability for large loops in a high field is small, and this approach is therefore feasible only at high temperatures or very weak fields.<br>[^ 2]: In the worm and SSE operator-loop algorithms, detailed balance is ensured by local probabilistic rules, and the resulting closed-loop configurations are always accepted.<br>[^ 3]: Two <em>link-discontinuities</em> (which are analogous to the source operators in the worm algorithm) are then created when the first entrance and exit spins are flipped, i.e., these legs will now be linked to legs <u>with different spins</u> . Configurations contributing to <em>Z</em> only contain links between same-spin legs. When the loop closes, the two discontinuities annihilate each other, and a new contributing configuration has then been generated.<br>[^ 4]: The probabilities for the different exit legs (<em>e</em> &#x3D; 1,…4), given the type of the vertex (<em>k</em> &#x3D; 1,…6) and an entrance leg (<em>i</em> &#x3D; 1,…4), are chosen such that detailed balance is satisfied. The sum of all these path weights over all exits <em>e</em> must equal the bare vertex weight. And the actual normalized exit probability is the path weight divided by the bare vertex weight.<br>[^ 5]: local detailed balance. The key observation leading to the directed-loop equations is that the weights for vertex-paths <em>i</em> → <em>e</em> that constitute each other’s reverses have to be equal: If the path <em>i</em> → <em>e</em> through vertex <em>k</em> leads to the vertex <em>k</em>′ when the entrance and exit spins have been flipped, then the reverse path <em>e</em> → <em>i</em> through <em>k</em>′ yields vertex <em>k</em></p><p>[^ 6]: 一般来说，对于S &gt; 1&#x2F;2和软核玻色子，最小化反弹概率不会导致有向环方程的唯一解，因此还必须施加一些其他约束。还指出，最小化反弹并不一定是最佳策略[31]（从一开始就预料到这不一定是绝对正确的）。此外，对于S &gt; 1的海森堡模型，为了完全消除反弹，必须为在构建环时存在的不连续性（源）分配不等于1的乘法权重。<br>[^ 7]: 更详细的说，原文讨论的是守恒定律是vertex上下两条腿自旋之和必须相等，这是哈密顿量与$S^z$对易造成的. 既如此，一个vertex入口腿出口腿必须都翻转，形成一个“双自旋翻转”的vertex，不难立马想到，这样的更新方式会在起点产生一个链接不连续性，因此，这里的守恒定律说的是，由守恒定律导致入口腿出口腿都要改变状态时，<u>只有loop闭合才可以消除不连续</u>. When there is a conservation law such that the state change at the exit leg is determined by the state change at the entrance leg the link discontinuities will only vanish when the path closes forming a loop…. In contrast, when there is no such conservation law a link discontinuity can vanish just because an exit state is not changed, although the entrance state <em>was</em> changed.<br>[^ 8]: 当存在守恒定律时，这种起始条件是不可能的，因为不会产生新的配置，但在没有守恒定律的情况下，即使入口腿上没有状态改变，退出腿上的状态改变仍然可能发生.  以bond的角度视横场算符，The transverse field introduces vertices where the sum of the spins on the lower two legs is not equal to the sum on the upper two legs.（出现三上一下或三下一上，导致不对称）Thus the conservation law utilized in Sec. IV cannot be used and we must include the possibilities of a state change on just one leg, the entrance or the exit leg, keeping the state on the other legs unchanged.<br>[^ 9]: Henelius, P. 2002 这篇文章就做了 “起点自旋不翻转” 这样的修正. 初始入口腿上没有链接不连续性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Directed-Loop-I&quot;&gt;&lt;a href=&quot;#Directed-Loop-I&quot; class=&quot;headerlink&quot; title=&quot;Directed Loop I&quot;&gt;&lt;/a&gt;Directed Loop I&lt;/h1&gt;&lt;p&gt;写在前面：本文是我最近想要写XXZ+</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ED</title>
    <link href="http://example.com/2024/02/02/ED/"/>
    <id>http://example.com/2024/02/02/ED/</id>
    <published>2024-02-02T12:16:59.000Z</published>
    <updated>2024-03-02T03:39:05.874Z</updated>
    
    <content type="html"><![CDATA[<p>For exact diagonalization (ED) studies, the foundational approach involves delving into several fundamental models for beginners. Examples include the lattice fermion Hubbard Model and quantum spin models such as the Ising Model and the XXZ Model (Heisenberg Model). </p><p>Our emphasis here is to introduce how to construct the Hamiltonian, commencing with the Heisenberg standard model and extending towards the XXZ model. The Ising Model assumes a more simplified form due to its absence of off-diagonal interaction terms.</p><h1 id="1D-Heisenberg-chain"><a href="#1D-Heisenberg-chain" class="headerlink" title="1D Heisenberg chain"></a>1D Heisenberg chain</h1><p>the Hamiltonian gives:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:1"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mi>H</mi><mo>&#x3D;</mo><mi>J</mi><munder><mo data-mjx-texclass="OP">&#x2211;</mo><mrow data-mjx-texclass="ORD"><mo>&lt;</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>&gt;</mo></mrow></munder><msub><mrow data-mjx-texclass="ORD"><mi mathvariant="bold">S</mi></mrow><mi>i</mi></msub><mo>&#x22C5;</mo><msub><mrow data-mjx-texclass="ORD"><mi mathvariant="bold">S</mi></mrow> <mi>j</mi></msub></mtd></mtr><mtr><mtd><mo accent="false" stretchy="false">&#x2192;</mo><mtext>&#xA0;</mtext><mi>H</mi><mo>&#x3D;</mo><mi>J</mi><munder><mo data-mjx-texclass="OP">&#x2211;</mo><mrow data-mjx-texclass="ORD"><mo fence="false" stretchy="false">&#x27E8;</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo fence="false" stretchy="false">&#x27E9;</mo></mrow></munder><mo stretchy="false">(</mo><msubsup><mi>S</mi><mi>i</mi><mi>x</mi></msubsup><msubsup><mi>S</mi><mi>j</mi><mi>x</mi></msubsup><mo>+</mo><msubsup><mi>S</mi><mi>i</mi><mi>y</mi></msubsup><msubsup><mi>S</mi><mi>j</mi><mi>y</mi></msubsup><mo>+</mo><msubsup><mi>S</mi><mi>i</mi><mi>z</mi></msubsup><msubsup><mi>S</mi><mi>j</mi><mi>z</mi></msubsup><mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p>According to the relationships:<math xmlns="http://www.w3.org/1998/Math/MathML">  <msup>    <mi>S</mi>    <mi>x</mi>  </msup>  <mo>&#x3D;</mo>  <mfrac>    <mn>1</mn>    <mn>2</mn>  </mfrac>  <mo stretchy="false">(</mo>  <msup>    <mi>S</mi>    <mo>+</mo>  </msup>  <mo>+</mo>  <msup>    <mi>S</mi>    <mo>&#x2212;</mo>  </msup>  <mo stretchy="false">)</mo>  <mo>,</mo>  <msup>    <mi>S</mi>    <mi>y</mi>  </msup>  <mo>&#x3D;</mo>  <mfrac>    <mn>1</mn>    <mrow>      <mn>2</mn>      <mi>i</mi>    </mrow>  </mfrac>  <mo stretchy="false">(</mo>  <msup>    <mi>S</mi>    <mo>+</mo>  </msup>  <mo>&#x2212;</mo>  <msup>    <mi>S</mi>    <mo>&#x2212;</mo>  </msup>  <mo stretchy="false">)</mo></math></p><p>By expressing the Hamiltonian in terms of the <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>S</mi><mo>+</mo></msup><mo>,</mo><msup><mi>S</mi><mo>&#x2212;</mo></msup></math>: </p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>H</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mi>i</mi><mo>+</mo></msubsup><msubsup><mi>S</mi><mi>j</mi><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mi>i</mi><mo>&#x2212;</mo></msubsup><msubsup><mi>S</mi><mi>j</mi><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mi>i</mi><mi>z</mi></msubsup><msubsup><mi>S</mi><mi>j</mi><mi>z</mi></msubsup><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>Given the presence of <strong>two sites</strong> representing spins, the size of the Hilbert space is determined by </p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mn>2</mn><mo stretchy="false">(</mo><mtext>Two spin orientations.</mtext><msup><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mn>2</mn><mo stretchy="false">(</mo><mtext>Two sites</mtext><mo stretchy="false">)</mo></mrow></msup><mo>&#x3D;</mo><mn>4</mn></math>, </p><p>Consequently, the Hamiltonian matrix for the system is a 4x4 matrix. Describing the two sites is straightforward, and we typically represent the Hamiltonian solely in operator form. From a matrix perspective, the interactions between operators are connected through tensor products to link matrices.</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>matrix representing:&#xA0;</mtext><mi>H</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>The fundamental idea behind Exact Diagonalization (ED) is as follows: After obtaining the matrix representation of the Hamiltonian, numerical diagonalization is performed on the Hamiltonian matrix. In theory, this process allows us to obtain all the eigenvalues and eigenvectors associated with the Hamiltonian, providing a comprehensive description of the system.</p><p>The method we are about to introduce below is the simplest and most foundational, relying on intuitive understanding, without involving the treatment of larger system sizes.</p><h1 id="Hamiltonian"><a href="#Hamiltonian" class="headerlink" title="Hamiltonian"></a>Hamiltonian</h1><p>Since we understand that the Hamiltonian matrix is in the form of the tensor product of operators, for a small number of sites, such as a 2-site matrix being 4x4, a 3-site matrix being 8x8, and a 4-site matrix being 16x16, the matrix elements can be manually calculated. Therefore, we can cross-verify the manually calculated matrix form with the matrix form provided by the code.</p><p>The manually calculated matrix form of the Hamiltonian is very easy to obtain and we will now focus on explaining the code implementation.</p><p>Firstly, we pre-store the matrix forms of the operators that constitute the Hamiltonian:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:1"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msup><mi>S</mi><mi>z</mi></msup><mo>&#x3D;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>&#x3C3;</mi><mi>z</mi></msup><mo>&#x3D;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><msup><mi>S</mi><mo>+</mo></msup><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><mi>I</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><mtext>&#xA0;</mtext><mi data-mjx-alternate="1">&#x210F;</mi><mo>&#x3D;</mo><mn>1</mn></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sz = <span class="number">0.5</span>*[<span class="number">1.0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">-1.0</span>];</span><br><span class="line">sp = [<span class="number">0</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">id = <span class="built_in">eye</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sz =</span><br><span class="line">0.5000         0</span><br><span class="line">     0   -0.5000</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp =</span><br><span class="line"> 0     1</span><br><span class="line"> 0     0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> =</span><br><span class="line"> 1     0</span><br><span class="line"> 0     1</span><br></pre></td></tr></table></figure><p>We do not redundantly store the operator <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>S</mi><mo>&#x2212;</mo></msup></math>, as it is evident that its matrix form is merely the transpose of <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>S</mi><mo>+</mo></msup></math>. In MATLAB, adding a ‘ to a matrix, such as A’, denotes the transpose of the matrix A.</p><p>Before we construct the Hamiltonian matrix, it is crucial to create(the matrix) and initialize:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">Sp0 = sp</span><br><span class="line">Sz0 = sz</span><br><span class="line">Id = <span class="built_in">eye</span>(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Sp1 = Sp0</span><br><span class="line">Sz1 = Sz0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">H =</span><br><span class="line">     0     0</span><br><span class="line">     0     0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sp0 =</span><br><span class="line">     0     1</span><br><span class="line">     0     0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sz0 =</span><br><span class="line">    0.5000         0</span><br><span class="line">         0   -0.5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Id =</span><br><span class="line">     1     0</span><br><span class="line">     0     1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sp1 =</span><br><span class="line">     0     1</span><br><span class="line">     0     0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sz1 =</span><br><span class="line">    0.5000         0</span><br><span class="line">         0   -0.5000</span><br></pre></td></tr></table></figure><p>Notice that we have additionally prepared operator matrices <code>Sp0, Sp1, Sz0, Sz1, Id</code> (MATLAB is case-sensitive, hence <code>Id</code> and <code>id</code> are distinct variables). These matrices have been initialized, and the form of the initialization is provided by the results.</p><p>With all the preparatory work completed, we can now proceed to the main loop for constructing the Hamiltonian.</p><p>Evidently, the core of this loop is:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> site=<span class="number">1</span>:L<span class="number">-1</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>The variable <code>site</code>, representing the site point coordinates, concludes the loop at <code>L-1</code> instead of <code>L</code>. This is because, in practice, when dealing with site &#x3D; i, then <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>j</mi><mo>&#x3D;</mo><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo>+</mo><mn>1</mn></math>. If the loop were to end at <code>L</code>, the value of j would exceed the length.</p><p>Now, we can contemplate how to create the code for our first 4x4 Hamiltonian matrix. It is:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>H</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>We can denote <math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup></math> as h. In MATLAB, the tensor product of two matrices can be represented using the <code>kron(A,B)</code> function. Therefore, <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mo>&#x3D;</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup></math>. Similarly, it is evident that <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>h</mi><mi>T</mi></msup><mo>&#x3D;</mo><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo>&#x3D;</mo><msup><mrow data-mjx-texclass="ORD"><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo></mrow><mi>T</mi></msup><mo>&#x2297;</mo><msup><mrow data-mjx-texclass="ORD"><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo stretchy="false">)</mo></mrow><mi>T</mi></msup><mo>&#x3D;</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup></math>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">0.5</span>*kron(Sp1, sp&#x27;);</span><br><span class="line">H = kron(H, id) + h + h&#x27; + kron(Sz1,sz);</span><br></pre></td></tr></table></figure><p>Here, both <code>Sp1 = sp</code> and <code>Sz1 = sz</code> are 2x2 matrices. After the tensor product, they become 4x4 matrices, i.e., <code>kron(H, id)</code>, <code>h</code>, <code>h&#39;</code>, and <code>kron(Sz1, sz)</code> are all 4x4 matrices. Matrix addition relies on having the same dimensions. The first term in the Hamiltonian matrix serves the purpose of expanding the initialized Hamiltonian matrix H from 2x2 to 4x4, maintaining consistency with the dimensions of the subsequent terms.</p><h5 id="2-spin-system"><a href="#2-spin-system" class="headerlink" title="2-spin system"></a>2-spin system</h5><p>If we consider only 2-spin system, it is unsurprising that the Hamiltonian is immediately fully constructed, here we print the result:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">H =</span><br><span class="line">    0.2500         0         0         0</span><br><span class="line">         0   -0.2500    0.5000         0</span><br><span class="line">         0    0.5000   -0.2500         0</span><br><span class="line">         0         0         0    0.2500</span><br><span class="line"></span><br><span class="line">4*H =</span><br><span class="line">     1     0     0     0</span><br><span class="line">     0    -1     2     0</span><br><span class="line">     0     2    -1     0</span><br><span class="line">     0     0     0     1</span><br></pre></td></tr></table></figure><p>Consistent with our manual derivation. The matrices below are four times the previous ones, which can be interpreted as factoring out J&#x2F;4. </p><h5 id="3-spin-system"><a href="#3-spin-system" class="headerlink" title="3-spin system"></a>3-spin system</h5><p>For 3-spin system, to maintain consistency in the dimensions of the Hamiltonian matrix, it should be:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:1"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mi>H</mi><mo>&#x3D;</mo><mo stretchy="false">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mi>z</mi></msubsup></mtd></mtr><mtr><mtd><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mi>z</mi></msubsup><mo stretchy="false">]</mo></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p>We call it Eq.7. It is not difficult to comprehend. The first row signifies the action of the interaction operators <math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>S</mi><mi>i</mi><mrow data-mjx-texclass="ORD"><mo>&#xB1;</mo><mo>,</mo><mi>z</mi></mrow></msubsup><msubsup><mi>S</mi><mi>j</mi><mrow data-mjx-texclass="ORD"><mo>&#x2213;</mo><mo>,</mo><mi>z</mi></mrow></msubsup></math> on lattice points where i&#x3D;1 and j&#x3D;2. However, to maintain dimensional consistency, it is as if the identity operator acts on the third lattice point and contributes to the matrix. (One can contemplate the consequences if we express H solely as <math xmlns="http://www.w3.org/1998/Math/MathML" displaystyle="true"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>+</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>&#x2212;</mo></msubsup><mo>+</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mi>z</mi></msubsup><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>+</mo><mo>.</mo><mo>.</mo></math><br>There would arise significant issues.) The Hamiltonian matrix is fundamentally expressed based on the chosen basis, and therefore, the order of the basis for each row and column has implications.)</p><p>It is noteworthy that the last row indicates the action of two-body interactions on points i&#x3D;3 and j&#x3D;1, suggesting the adoption of periodic boundary conditions in this scenario.</p><p>Now, let’s delve into each row specifically:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:2"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msub><mi>H</mi><mn>1</mn></msub><mo>&#x3D;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd><mo accent="false" stretchy="false">&#x2192;</mo><msub><mi>H</mi><mn>1</mn></msub><mo>&#x3D;</mo><msub><mi>H</mi><mrow data-mjx-texclass="ORD"><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>&#x2297;</mo><mi>I</mi></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p>we realize that the Hamiltonian <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>H</mi><mn>1</mn></msub></math> in the first row, factoring out <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x2297;</mo><msub><mi>I</mi><mn>3</mn></msub></math>, is essentially equivalent to the Hamiltonian for two sites that we previously calculated, denoted as <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>H</mi><mrow data-mjx-texclass="ORD"><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>&#x3D;</mo><msub><mi>H</mi><mrow data-mjx-texclass="ORD"><mn>2</mn><mo>&#x2212;</mo><mi>s</mi><mi>p</mi><mi>i</mi><mi>n</mi></mrow></msub></math>. Consequently, in the code:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% when site=1 for 2-spin</span></span><br><span class="line">h = <span class="number">0.5</span>*kron(Sp1, sp&#x27;);</span><br><span class="line">H = kron(H, id) + h + h&#x27; + kron(Sz1,sz);</span><br><span class="line"></span><br><span class="line"><span class="comment">% for 3-spin</span></span><br><span class="line">H_1 = kron(H,id)</span><br></pre></td></tr></table></figure><p>We have implemented the first row of the total Hamiltonian(Eq.7).</p><p>Now, the second row of Hamiltonian(Eq.7):</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <msub>    <mi>H</mi>    <mn>2</mn>  </msub>  <mo>&#x3D;</mo>  <mfrac>    <mn>1</mn>    <mn>2</mn>  </mfrac>  <mo stretchy="false">(</mo>  <msub>    <mi>I</mi>    <mn>1</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>2</mn>    <mo>+</mo>  </msubsup>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mo>&#x2212;</mo>  </msubsup>  <mo>+</mo>  <msub>    <mi>I</mi>    <mn>1</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>2</mn>    <mo>&#x2212;</mo>  </msubsup>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mo>+</mo>  </msubsup>  <mo stretchy="false">)</mo>  <mo>+</mo>  <msub>    <mi>I</mi>    <mn>1</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>2</mn>    <mi>z</mi>  </msubsup>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mi>z</mi>  </msubsup></math></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sp1 = kron(Id, sp); </span><br><span class="line">Sz1 = kron(Id, sz); </span><br><span class="line"></span><br><span class="line"><span class="comment">% outside:</span></span><br><span class="line">h = <span class="number">0.5</span>*kron(Sp1, sp&#x27;);</span><br><span class="line">H_2 = h + h&#x27; + kron(Sz1,sz);</span><br></pre></td></tr></table></figure><p>Still remember that our <code>Sp1</code> and <code>Sz1</code> were initialized as <code>sp</code> and <code>sz</code> 2x2 matrices? After the operation <code>Sp1 = kron(Id, sp)</code>, it represents: <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup></math>. Similarly, <code>Sz1 = kron(Id, sz)</code> represents <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup></math>. Considering them as a whole, the term <code>h = 0.5*kron(Sp1, sp&#39;)</code> now represents <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>&#x2F;</mo></mrow><mn>2</mn><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>&#x2212;</mo></msubsup><mo stretchy="false">)</mo></math>, and <code>h&#39;</code> represents <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>&#x2F;</mo></mrow><mn>2</mn><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mo>&#x2212;</mo></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>+</mo></msubsup><mo stretchy="false">)</mo></math>. Finally, the term <code>kron(Sz1,sz)</code> represents <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mn>1</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>2</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mi>z</mi></msubsup></math>. This way, we have completed the construction of the second row of the Hamiltonian.</p><p>For the third row of Hamiltonian(Eq.7) , we handle the last point, where i &#x3D; 3:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sp0 = kron(Sp0, id);</span><br><span class="line">Sz0 = kron(Sz0, id);</span><br><span class="line"></span><br><span class="line"><span class="comment">% outside:</span></span><br><span class="line">h = <span class="number">0.5</span>*kron(Sp0, sp&#x27;); </span><br><span class="line">H = H + h + h&#x27; + kron(Sz0,sz); </span><br></pre></td></tr></table></figure><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <msub>    <mi>H</mi>    <mn>3</mn>  </msub>  <mo>&#x3D;</mo>  <mfrac>    <mn>1</mn>    <mn>2</mn>  </mfrac>  <mo stretchy="false">(</mo>  <msubsup>    <mi>S</mi>    <mn>1</mn>    <mo>+</mo>  </msubsup>  <mo>&#x2297;</mo>  <msub>    <mi>I</mi>    <mn>2</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mo>&#x2212;</mo>  </msubsup>  <mo>+</mo>  <msubsup>    <mi>S</mi>    <mn>1</mn>    <mo>&#x2212;</mo>  </msubsup>  <mo>&#x2297;</mo>  <msub>    <mi>I</mi>    <mn>2</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mo>+</mo>  </msubsup>  <mo stretchy="false">)</mo>  <mo>+</mo>  <msubsup>    <mi>S</mi>    <mn>1</mn>    <mi>z</mi>  </msubsup>  <mo>&#x2297;</mo>  <msub>    <mi>I</mi>    <mn>2</mn>  </msub>  <mo>&#x2297;</mo>  <msubsup>    <mi>S</mi>    <mn>3</mn>    <mi>z</mi>  </msubsup></math></p><p>Here, <code>Sp0 = kron(Sp0, id)</code> with the initialization <code>Sp0 = sp</code> represents <math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub></math>. Therefore, <code>h = 0.5*kron(Sp0, sp&#39;)</code> corresponds to <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>&#x2F;</mo></mrow><mn>2</mn><mo stretchy="false">(</mo><msubsup><mi>S</mi><mn>1</mn><mo>+</mo></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mo>&#x2212;</mo></msubsup><mo stretchy="false">)</mo></math>. Similarly, <math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>S</mi><mn>1</mn><mi>z</mi></msubsup><mo>&#x2297;</mo><msub><mi>I</mi><mn>2</mn></msub><mo>&#x2297;</mo><msubsup><mi>S</mi><mn>3</mn><mi>z</mi></msubsup></math> represents the treatment for the last point i&#x3D;3. This completes the construction of the three components of the Hamiltonian for the 3-spin system under periodic boundary conditions.</p><p>Below is the complete code, composed of the snippets above, with some logical changes for functionality linkage. With the presence of comments, it should be comprehensible for readers:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 3-spin example:</span></span><br><span class="line"><span class="keyword">for</span> site=<span class="number">1</span>:L<span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">    h = <span class="number">0.5</span>*kron(Sp1, sp&#x27;) </span><br><span class="line">    H = kron(H, id) + h + h&#x27; + kron(Sz1,sz)</span><br><span class="line">    <span class="comment">% If L = 2, the process concludes at this point. The code above will only execute once.</span></span><br><span class="line">    <span class="comment">% If L = 3, The first term H = kron(H, id) represents H_1 (Regardless of the number of points (L &gt; 2), it always represents the Hamiltonian for the first row H_1 = H_old otimes I.)</span></span><br><span class="line">    <span class="comment">% ..h + h&#x27; + kron(Sz1,sz) represents H_2</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% Here is the code for extending the matrix when L &gt; 2.</span></span><br><span class="line">    <span class="keyword">if</span> L&gt;<span class="number">2</span></span><br><span class="line">        <span class="comment">% The following is our handling process for the last point: i = L-1, j = L = 1</span></span><br><span class="line">        <span class="keyword">if</span> site == L<span class="number">-1</span></span><br><span class="line">            h = <span class="number">0.5</span>*kron(Sp0, sp&#x27;);</span><br><span class="line">            H = H + h + h&#x27; + kron(Sz0,sz); <span class="comment">% H_3</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% When L &gt; 2 but site = 1, we handle matrices before entering the next iteration:site=L-1=2</span></span><br><span class="line">        <span class="keyword">if</span> site &lt; L<span class="number">-1</span></span><br><span class="line">            Sp1 = kron(Id, sp); </span><br><span class="line">            Sz1 = kron(Id, sz);</span><br><span class="line"></span><br><span class="line">            Sp0 = kron(Sp0, id);</span><br><span class="line">            Sz0 = kron(Sz0, id);</span><br><span class="line">            Id = <span class="built_in">eye</span>(<span class="built_in">size</span>(Sp0)); </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Finally, let’s output the Hamiltonian matrix and compare it with the manually derived form.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">H =</span><br><span class="line">    0.7500         0         0         0         0         0         0         0</span><br><span class="line">         0   -0.2500    0.5000         0    0.5000         0         0         0</span><br><span class="line">         0    0.5000   -0.2500         0    0.5000         0         0         0</span><br><span class="line">         0         0         0   -0.2500         0    0.5000    0.5000         0</span><br><span class="line">         0    0.5000    0.5000         0   -0.2500         0         0         0</span><br><span class="line">         0         0         0    0.5000         0   -0.2500    0.5000         0</span><br><span class="line">         0         0         0    0.5000         0    0.5000   -0.2500         0</span><br><span class="line">         0         0         0         0         0         0         0    0.7500</span><br><span class="line">         </span><br><span class="line">4*H =</span><br><span class="line">     3     0     0     0     0     0     0     0</span><br><span class="line">     0    -1     2     0     2     0     0     0</span><br><span class="line">     0     2    -1     0     2     0     0     0</span><br><span class="line">     0     0     0    -1     0     2     2     0</span><br><span class="line">     0     2     2     0    -1     0     0     0</span><br><span class="line">     0     0     0     2     0    -1     2     0</span><br><span class="line">     0     0     0     2     0     2    -1     0</span><br><span class="line">     0     0     0     0     0     0     0     3</span><br></pre></td></tr></table></figure><hr><p>The code demonstrated above is also applicable for L &#x3D; 4, L &#x3D; 5, L &#x3D; 6, … since the implementation logic remains the same and covers cases with different numbers of lattice sites. I won’t go into excessive details here. Instead, let’s just print out the Hamiltonian matrix for a 4-spin system. Readers can compare it with the manually derived form:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>16</mn><mo>&#xD7;</mo><mn>16</mn></math> Hamiltonian matrix of standard Heisenberg Model:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">H = J/4 x </span><br><span class="line"></span><br><span class="line">     4     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0</span><br><span class="line">     0     0     2     0     0     0     0     0     2     0     0     0     0     0     0     0</span><br><span class="line">     0     2     0     0     2     0     0     0     0     0     0     0     0     0     0     0</span><br><span class="line">     0     0     0     0     0     2     0     0     0     0     2     0     0     0     0     0</span><br><span class="line">     0     0     2     0     0     0     0     0     2     0     0     0     0     0     0     0</span><br><span class="line">     0     0     0     2     0    -4     2     0     0     2     0     0     2     0     0     0</span><br><span class="line">     0     0     0     0     0     2     0     0     0     0     2     0     0     0     0     0</span><br><span class="line">     0     0     0     0     0     0     0     0     0     0     0     2     0     0     2     0</span><br><span class="line">     0     2     0     0     2     0     0     0     0     0     0     0     0     0     0     0</span><br><span class="line">     0     0     0     0     0     2     0     0     0     0     2     0     0     0     0     0</span><br><span class="line">     0     0     0     2     0     0     2     0     0     2    -4     0     2     0     0     0</span><br><span class="line">     0     0     0     0     0     0     0     2     0     0     0     0     0     2     0     0</span><br><span class="line">     0     0     0     0     0     2     0     0     0     0     2     0     0     0     0     0</span><br><span class="line">     0     0     0     0     0     0     0     0     0     0     0     2     0     0     2     0</span><br><span class="line">     0     0     0     0     0     0     0     2     0     0     0     0     0     2     0     0</span><br><span class="line">     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     4</span><br></pre></td></tr></table></figure><h3 id="Appendix-A-tensor-products-rules"><a href="#Appendix-A-tensor-products-rules" class="headerlink" title="Appendix A: tensor products rules"></a>Appendix A: tensor products rules</h3><p><em>For more details, please refer to Wikipedia.</em></p><p>Tensor product does not require matrices to have the same dimensions. Suppose there is a 2x2 matrix A and a 2x2 matrix B for this demonstration. </p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:3"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mi>A</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>,</mo><mi>B</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:4"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mi>A</mi><mo>&#x2297;</mo><mi>B</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>&#x2297;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:5"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd><mtd><mn>0</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr><mtr><mtd><mn>0</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd><mtd><mo>&#x2212;</mo><mn>1</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd><mn>1</mn></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd></mtd><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr><mtr><mtd></mtd><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd><mtd></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:6"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mi>B</mi><mo>&#x2297;</mo><mi>A</mi><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>&#x2297;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:7"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd><mtd><mn>1</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr><mtr><mtd><mn>1</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd><mtd><mn>0</mn><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd></mtd><mtd><mn>1</mn></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd></mtd><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd><mtd></mtd><mtd></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><h3 id="Appendix-B-Pauli-matrices"><a href="#Appendix-B-Pauli-matrices" class="headerlink" title="Appendix B: Pauli matrices"></a>Appendix B: Pauli matrices</h3><p>Pauli matrix:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:9"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msup><mi>&#x3C3;</mi><mi>z</mi></msup><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mo>&#x2212;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo><msup><mi>&#x3C3;</mi><mi>x</mi></msup><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo><msup><mi>&#x3C3;</mi><mi>y</mi></msup><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd><mo>&#x2212;</mo><mi>i</mi></mtd></mtr><mtr><mtd><mi>i</mi></mtd><mtd></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p>The relationship between <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>&#x3D;</mo><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>&#x2F;</mo></mrow><mn>2</mn></math> operators and Pauli matrices is as follows:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mrow>    <mover>      <mi>S</mi>      <mo stretchy="false">&#x2192;</mo>    </mover>  </mrow>  <mo>&#x3D;</mo>  <mfrac>    <mi data-mjx-alternate="1">&#x210F;</mi>    <mn>2</mn>  </mfrac>  <mrow>    <mover>      <mi>&#x3C3;</mi>      <mo stretchy="false">&#x2192;</mo>    </mover>  </mrow>  <mo>,</mo>  <mrow>    <mover>      <mi>&#x3C3;</mi>      <mo stretchy="false">&#x2192;</mo>    </mover>  </mrow>  <mo>&#x3D;</mo>  <mo stretchy="false">(</mo>  <msup>    <mi>&#x3C3;</mi>    <mi>x</mi>  </msup>  <mo>,</mo>  <msup>    <mi>&#x3C3;</mi>    <mi>y</mi>  </msup>  <mo>,</mo>  <msup>    <mi>&#x3C3;</mi>    <mi>z</mi>  </msup>  <mo stretchy="false">)</mo></math></p><p>We typically assume <math xmlns="http://www.w3.org/1998/Math/MathML"><mi data-mjx-alternate="1">&#x210F;</mi><mo>&#x3D;</mo><mn>1</mn></math>, and given the relationship between the spin operator with <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>&#x3D;</mo><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>&#x2F;</mo></mrow><mn>2</mn></math> and the Pauli matrices, it is possible to derive the matrix forms of the raising and lowering spin operators based on these relationships.</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:11"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msup><mi>S</mi><mo>+</mo></msup><mo>&#x3D;</mo><mfrac><mi data-mjx-alternate="1">&#x210F;</mi><mn>2</mn></mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>+</mo><mi>i</mi><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mi>i</mi></mtd></mtr><mtr><mtd><mi>i</mi></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>&#x3D;</mo><mfrac><mi data-mjx-alternate="1">&#x210F;</mi><mn>2</mn></mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn><mo>&#x2212;</mo><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn><mo>&#x2212;</mo><mi>i</mi></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>&#x3D;</mo><mi data-mjx-alternate="1">&#x210F;</mi><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:12"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msup><mi>S</mi><mo>&#x2212;</mo></msup><mo>&#x3D;</mo><mfrac><mi data-mjx-alternate="1">&#x210F;</mi><mn>2</mn></mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>&#x2212;</mo><mi>i</mi><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mo>&#x2212;</mo><mi>i</mi></mtd></mtr><mtr><mtd><mi>i</mi></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>&#x3D;</mo><mfrac><mi data-mjx-alternate="1">&#x210F;</mi><mn>2</mn></mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn><mo>&#x2212;</mo><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn><mo>+</mo><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>&#x3D;</mo><mi data-mjx-alternate="1">&#x210F;</mi><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><p>Clearly,</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn:13"></mtd><mtd><mtable rowspacing=".5em" columnspacing="1em" displaystyle="true"><mtr><mtd><msup><mi>S</mi><mo>+</mo></msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2191;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>&#x3D;</mo><mn>0</mn><mo>,</mo><msup><mi>S</mi><mo>+</mo></msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2193;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2191;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow></mtd></mtr><mtr><mtd><msup><mi>S</mi><mo>&#x2212;</mo></msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2191;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>&#x3D;</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2193;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>,</mo><msup><mi>S</mi><mo>&#x2212;</mo></msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">&#x2193;</mo></mrow><mo data-mjx-texclass="CLOSE">&#x27E9;</mo></mrow><mo>&#x3D;</mo><mn>0</mn></mtd></mtr></mtable></mtd></mlabeledtr></mtable></math></p><h3 id="Appendix-C-external-field"><a href="#Appendix-C-external-field" class="headerlink" title="Appendix C: external field"></a>Appendix C: external field</h3><p>1D Longitudinal field</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sh = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">idnew = id;</span><br><span class="line">szh = sz;</span><br><span class="line"><span class="keyword">for</span> site=<span class="number">1</span>:L<span class="number">-1</span> <span class="comment">%L-1</span></span><br><span class="line"></span><br><span class="line">    sh = kron(sh,id) + hb * kron(szh,id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L&gt;<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> site == L<span class="number">-1</span></span><br><span class="line">            sh = sh + hb*kron(idnew,sz);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> site &lt; L<span class="number">-1</span></span><br><span class="line">            szh = kron(idnew, sz); </span><br><span class="line">            idnew = <span class="built_in">eye</span>(<span class="built_in">size</span>(szh)); </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">%(For L=2)</span></span><br><span class="line">     sh = sh + hb * kron(id,sz);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>1D Transverse field</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sx = [<span class="number">0</span>,<span class="number">1.0</span>;<span class="number">1.0</span>,<span class="number">0</span>];<span class="comment">%notice here is Pauli Matrix</span></span><br><span class="line">iidnew = id;</span><br><span class="line">sxg = sx;</span><br><span class="line">sgamma = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> site=<span class="number">1</span>:L<span class="number">-1</span> <span class="comment">%L-1</span></span><br><span class="line"></span><br><span class="line">    sgamma = kron(sgamma,id) + <span class="built_in">gamma</span> * kron(sxg,id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L&gt;<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> site == L<span class="number">-1</span></span><br><span class="line">            sgamma = sgamma + <span class="built_in">gamma</span> * kron(iidnew,sx);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> site &lt; L<span class="number">-1</span></span><br><span class="line">            sxg = kron(iidnew, sx); </span><br><span class="line">            iidnew = <span class="built_in">eye</span>(<span class="built_in">size</span>(sxg)); </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    sgamma = sgamma + <span class="built_in">gamma</span> * kron(id,sx);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;For exact diagonalization (ED) studies, the foundational approach involves delving into several fundamental models for beginners. Example</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>use hexo</title>
    <link href="http://example.com/2024/02/02/use-hexo/"/>
    <id>http://example.com/2024/02/02/use-hexo/</id>
    <published>2024-02-02T11:54:41.000Z</published>
    <updated>2024-04-03T03:56:04.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装了home-brew之后，安装 Hexo 所需要的 Git 和 Node.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br><span class="line">$ brew install node</span><br></pre></td></tr></table></figure><p>检查是否安装成功:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">$ node -v</span><br><span class="line">$ git --version</span><br></pre></td></tr></table></figure><p>安装 Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>为Hexo创建一个初始源文件夹</p><p>Cd in 想要的路径中, 执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><hr><p>这里简单介绍一些hexo使用指令</p><p>对于hexo创建一个 ~ blog的文件夹，那么blog默认为根目录，所谓的在根目录底下执行，就是在blog这个文件夹底下执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd .../blog</span><br></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>新建一篇博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo n &quot;name&quot;</span><br></pre></td></tr></table></figure><p>在根目录的 source 文件夹底下 _posts 中会出现你创建的 blog.md</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ hexo n <span class="string">&quot;use anaconda&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: ~/.../blog/source/_posts/use-anaconda.md</span><br></pre></td></tr></table></figure><p>我们在根目录下预安装能够<u>加载本地图片</u>的插件</p><p>在根目录下执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install https://github.com/xcodebuild/hexo-asset-image.git --save</span><br></pre></td></tr></table></figure><p>在这个 .md文件中写完内容之后，保存，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo g</span><br></pre></td></tr></table></figure><p>然后部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo d</span><br></pre></td></tr></table></figure><p>可以在本地进行预览：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo s</span><br></pre></td></tr></table></figure><p>将网址点开可以预览.</p><h4 id="插入图片的问题"><a href="#插入图片的问题" class="headerlink" title="插入图片的问题"></a>插入图片的问题</h4><p>之前我们已经安装了插件，在 _posts 文件夹中会出现和文章名字相同的文件夹，将想要插入的图片复制到该文件夹中</p><p>然后在Markdown环境下插入图片格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Fig x</span>](<span class="link"> ./picture.png</span>)</span><br></pre></td></tr></table></figure><p>注意，前面的 <code> ./</code> 一定不能省略，点前面有一个空格</p><h4 id="公式显示的问题"><a href="#公式显示的问题" class="headerlink" title="公式显示的问题"></a>公式显示的问题</h4><p>目前找到的一个解决方式是使用 <a href="https://www.latexlive.com/">https://www.latexlive.com</a> 网站转出为 MathML 的格式（Typora也可以转，但是会有很多换行而识别得破破烂烂）</p><p>默认转出格式是另起一行居中</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>a</mi>  <mo>+</mo>  <mi>b</mi>  <mo>+</mo>  <mi>c</mi></math></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;  &lt;mi&gt;a&lt;/mi&gt;  &lt;mo&gt;+&lt;/mo&gt;  &lt;mi&gt;b&lt;/mi&gt;  &lt;mo&gt;+&lt;/mo&gt;  &lt;mi&gt;c&lt;/mi&gt;&lt;/math&gt;</span><br></pre></td></tr></table></figure><p>如果不想要居中，而是行间公式，把 <code> display=&quot;block&quot;</code> 删掉即可</p><p>最后最好用Typora源代码模式检查一遍</p><hr><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>(2024.4)</p><p>重新搞了Latex识别的插件，现在可以直接使用”$$”来使用公式</p><p>插入图片依旧使用上面说的指令，一定要记得，这是调用同名文件夹里的图片(图片一定要放到同名文件夹里)，所以Typora可能显示不出来图片，但是网站上可以读取.</p><p>现在可以更改图片大小:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot; ./p2.png&quot;</span> style=<span class="string">&quot;width: 20%; &quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>参考教程：</p><p><a href="https://www.cnblogs.com/nuccch/p/17010471.html">https://www.cnblogs.com/nuccch/p/17010471.html</a></p><p><a href="https://www.jianshu.com/p/67f3281cfc01">https://www.jianshu.com/p/67f3281cfc01</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h2&gt;&lt;p&gt;安装了home-brew之后，安装 Hexo 所需要的 Git 和 Node.js&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Confinement of spinons Part.I</title>
    <link href="http://example.com/2024/02/02/Confinement-of-spinons-Part-I/"/>
    <id>http://example.com/2024/02/02/Confinement-of-spinons-Part-I/</id>
    <published>2024-02-02T11:27:35.000Z</published>
    <updated>2024-02-02T11:43:42.273Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome! This is my first post. </p><p>Fig 1: Zero magnetic field state. Néel type. </p><p><img src="/2024/02/02/Confinement-of-spinons-Part-I/p1.png" alt="Fig 1"></p><p>In the Ising limit, a local spin flip decomposes into two spinons;</p><p>In the Heisenberg limit, it decomposes into a rapidly converging series of states containing two, four and higher even numbers of such spinons. </p><p><strong>spin-1&#x2F;2 Heisenberg antiferromagnetic chain</strong></p><blockquote><p>Its exact ground state is a macroscopic singlet entangling all spins in the chain. Its elementary excitations, called <u>spinons</u>, are fractional spin-1&#x2F;2 quasiparticles created and detected in pairs by neutron scattering.</p></blockquote><p>The gapless fractionalized excitations are called spinons. The elementary excitation, the spinon, carries spin-1&#x2F;2 and can be pictorially associated with an individually propagating domain wall. </p><p>In zero magnetic field the spins-1&#x2F;2 entangle into a macroscopic singlet <math xmlns="http://www.w3.org/1998/Math/MathML">  <msub>    <mrow>      <mover>        <mi>S</mi>        <mo stretchy="false">&#x2192;</mo>      </mover>    </mrow>    <mrow>      <mi>t</mi>      <mi>o</mi>      <mi>t</mi>    </mrow>  </msub>  <mo>&#x3D;</mo>  <mn>0</mn></math>      The inelastically scattered neutron provokes  <math xmlns="http://www.w3.org/1998/Math/MathML">  <msub>    <mrow>      <mover>        <mi>S</mi>        <mo stretchy="false">&#x2192;</mo>      </mover>    </mrow>    <mrow>      <mi>t</mi>      <mi>o</mi>      <mi>t</mi>    </mrow>  </msub>  <mo>&#x3D;</mo>  <mn>1</mn></math> excitations, which we first imagine, in the Ising limit, as a local spin flip surrounded by two domain walls(kink). And then, these domain walls delocalize owing to the terms <math xmlns="http://www.w3.org/1998/Math/MathML">  <mo stretchy="false">(</mo>  <msup>    <mi>S</mi>    <mo>+</mo>  </msup>  <msup>    <mi>S</mi>    <mo>&#x2212;</mo>  </msup>  <mo>+</mo>  <msup>    <mi>S</mi>    <mo>&#x2212;</mo>  </msup>  <msup>    <mi>S</mi>    <mo>+</mo>  </msup>  <mo stretchy="false">)</mo></math> and propagate individually. </p><p>More important,     approaching the Heisenberg limit, the local spin flip can no longer be represented by two spinons alone, but rather decomposes in a rapidly converging series of states containing two, four and higher even numbers of spinons.    The picture shows two- and four-spinons which are main contribution of elementary excitation.</p><p>Whereas each spinon has a discrete energy-momentum relation, the excitation spectrum is composed of <strong>spinon pairs</strong> (and higher even numbered spinon states with <math xmlns="http://www.w3.org/1998/Math/MathML">  <msub>    <mrow>      <mover>        <mi>S</mi>        <mo stretchy="false">&#x2192;</mo>      </mover>    </mrow>    <mrow>      <mi>t</mi>      <mi>o</mi>      <mi>t</mi>    </mrow>  </msub>  <mo>&#x3D;</mo>  <mn>1</mn></math>, and will therefore be continuous.        Two-spinons.  A localized spin flip exactly projects onto a state with two spinons. As these domain walls are localized, the state immediately after the spin flip can, be represented as a combination of two-spinon states with  <u>a broad momentum distribution</u> :  a spinon has the (0 ~  <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math>) momentum and another spinon must be (<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math> ~  0), since spinons separate two sections of the macroscopic singlet ground state wavefunction that are phase-shifted by <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math>. </p><p>Domain wall pair excitations have then a finite threshold energy and are  <u>bound or confined</u>  by the magnetic field.</p><p><u>Fully polarized state</u></p><p>is identical to the classical ground state, which if we neglect all commutation relations of spin operators.  Thus, dispersion and intensity of the low-energy excitation spectrum are correctly described, by linear spin-wave theory, and for which, the elementary quasiparticles are non-interacting magnons.</p><p>Fig 2: Fully polarized state. Gound state and “single-flip” excitation.</p><p><img src="/2024/02/02/Confinement-of-spinons-Part-I/p2.png" alt="Fig 2"></p><p>The creation of a magnon by inelastic scattering of a neutron can be imagined as a single spin flip.  The Zeeman energy prevents any growth of the flipped section.(middle)</p><p>This magnon can classically be visualized as a spin wave(left), a coherent precession of the local spin expectation value around the field direction.</p><p>Domain wall propagation is achieved through S+S- term in Hamiltonian.(right)</p><p>The magnon in the fully polarized state can be understood as a firmly bound domain wall pair that propagates and delocalizes as a single entity.  This results in a <strong>discrete</strong> energy-momentum dispersion relation of the magnon.</p><p>Confinement of spinons</p><blockquote><p>Domain wall pair excitations have then a finite threshold energy and are <u>bound or confined</u> by the magnetic field.</p></blockquote><p>Now we are going to talk about “Confinement”.</p><p>Confinement is a process by which particles with fractional quantum numbers bind together to form quasiparticles with integer quantum numbers. </p><p>At sufficiently low temperatures the weak coupling between chains can, induce an attractive interaction between pairs of spinons, that increases with their separation and thus <strong>leads to confinement</strong>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome! This is my first post. &lt;/p&gt;
&lt;p&gt;Fig 1: Zero magnetic field state. Néel type. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/02/02/Confinement-of-spinons</summary>
      
    
    
    
    
  </entry>
  
</feed>
